<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue插件以及自定义指令实践]]></title>
    <url>%2Fblog%2F2019%2F11%2F04%2FVue%E6%8F%92%E4%BB%B6%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[背景由于项目需要引入countup.js插件用于将数字实现累加动画效果,而且由于是vue项目,发现文档里有专门对vue封装的组件vue-countup-v2,所以自然而然yarn add countup.js vue-countup-v2然后根据文档一步一步下来,一切ok随后想了想,需要安装两个依赖并且vue-countup-v2只是一个组件封装,那么为什么不用vue directives指令来写呢? vue-directives自定义指令vue指令其实随处都会用到,比如v-if,v-show,v-for等等,对于特殊场景,vue也提供注册自定义指令的方法,有两种方法可以注册自定义指令,分别是Vue.directive注册全局指令以及在组件中配置directives注册局部指令,在这里,全局指令更适合本场景,所以决定使用Vue.directive 开始编写123456789101112// main.jsimport &#123; CountUp &#125; from 'countup.js'Vue.directive('countUp', &#123; bind (el) &#123; el.countUpComponent = new CountUp(el, 0, &#123; duration: 1 &#125;) &#125;, update (el, binding) &#123; el.countUpComponent.update(binding.value || 0) &#125; &#125;) 在这里,bind方法只调用一次，指令第一次绑定到元素时调用。在这里可以进行初始化Countup对象,之所以不用inserted方法是因为根据文档描述,inserted方法并不一定可以获取到dom对象示例,这就会导致new Countup示例时报错在el对象上挂载实例对象,这样,在update触发时,可以执行update方法触发数字更新动画这里,binding对象可以获取到我们传给指令的参数,进而执行update方法 vue插件编写其实,上述代码已经可以实现功能了,但是为了降低代码的耦合性,我们可以将它封装成一个插件写vue插件需要暴露一个install方法,这个方法接收两个参数,第一个参数是Vue构造器，第二个参数是一个可选的选项对象1234567891011121314151617// countUp-directive.jsimport &#123; CountUp &#125; from 'countup.js'export default &#123; install (Vue, options) &#123; Vue.directive('countUp', &#123; bind (el) &#123; el.countUpComponent = new CountUp(el, 0, &#123; duration: 1 &#125;) &#125;, update (el, binding) &#123; el.countUpComponent.update(binding.value || 0) &#125; &#125;) &#125;&#125; 123// main.jsimport CountUp from './countup-directive'Vue.use(CountUp) 使用使用就很简单了,直接看代码1&lt;em v-countUp=&quot;countNumber&quot;&gt;&lt;/em&gt; 传入countNumber就可以了 相关文档Vue自定义指令Vue插件countup.js]]></content>
  </entry>
  <entry>
    <title><![CDATA[也还好]]></title>
    <url>%2Fblog%2F2019%2F10%2F04%2F%E4%B9%9F%E8%BF%98%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[我现在坐在太阳底下来往的人都打着伞我不愿打伞我喜欢这个温度我看见一束花紫色的你知道我在说什么吗我是说凉薄也好]]></content>
  </entry>
  <entry>
    <title><![CDATA[在vue和react中处理异步组件加载状态]]></title>
    <url>%2Fblog%2F2019%2F09%2F24%2F%E5%9C%A8react%E5%92%8Cvue%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[异步组件加载与webpack SplitChunks在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。利用webpack对代码进行分割是懒加载的前提，懒加载就是异步调用组件，需要时候才下载（按需加载）。通过异步组件结合webpack的代码按需加载，我们可以得到两点好处： 用不到的组件不会加载，因此网页打开速度会很快，当你用到这个组件的时候，才会通过异步请求进行加载； 缓存组件，通过异步加载的组件会缓存起来，当你下一次再用到这个组件时，丝毫不会有任何的疑迟，组件很快会从缓存中加载出来。 关于webpack splitChunks,可以阅读腾讯IMWeb的文章,介绍的非常详细了,点击链接异步加载虽然由以上的好处,但是必然有一个问题,就是在浏览器下载异步组件的代码时(比如新页面路由切换),如果网速比较慢的话,会显示白屏界面。那么,如何实现在浏览器下载异步组件的同时让页面展示诸如loading类的等待界面呢? vue中处理异步组件加载状态声明方法1234567891011121314151617181920212223242526/** * 处理路由页面切换时，异步组件加载过渡的处理函数 * @param &#123;Object&#125; AsyncView 需要加载的组件，如 import('@/components/home/Home.vue') * @return &#123;Object&#125; 返回一个promise对象 */function lazyLoadView (AsyncView) &#123; const AsyncHandler = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: AsyncView, // 异步组件加载时使用的组件 loading: import('@/components/public/RouteLoading.vue'), // 加载失败时使用的组件 error: import('@/components/public/RouteError.vue'), // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 10000 &#125;); return Promise.resolve(&#123; functional: true, render (h, &#123; data, children &#125;) &#123; return h(AsyncHandler, data, children); &#125; &#125;);&#125; 引入路由并使用1234567891011const helloWorld = () =&gt; lazyLoadView(import('@/components/helloWorld'))&#123; routes: [ &#123; path: '/helloWorld', name: 'helloWorld', component: helloWorld &#125; ]&#125; 相关文档链接 react中处理异步组件加载状态react-loadablereact-loadable是基于react的高阶组件,它专门用来处理异步路由加载状态,并且可以用于SSR服务端渲染相关文档链接 使用react-loadableharmony123456789101112131415import Loadable from 'react-loadable';import Loading from './my-loading-component';const LoadableComponent = Loadable(&#123; loader: () =&gt; import('./my-component'), loading: Loading, delay: 200, timeout: 10000,&#125;);export default class App extends React.Component &#123; render() &#123; return &lt;LoadableComponent/&gt; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[用eslint & prettier & pre-commit规范前端代码格式]]></title>
    <url>%2Fblog%2F2019%2F09%2F20%2F%E7%94%A8eslint%2Cprettier%2Cpre-commit%E8%A7%84%E8%8C%83%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言每个人的代码风格不一,但对于团队来说,代码风格的统一有助于团队之间的协作,良好的代码风格更会令人赏心悦目。但是现实总会不如愿,可能一开始很规范的项目随着工作进度的推展,代码也会变得凌乱。人为的进行代码风格检查无疑是一种低效率且不可靠的方式,所以我们需要借助工具来进行强制的代码风格检查 eslintESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。ESLint被设计为完全可配置的，主要有两种方式来配置ESLint： 在注释中配置：使用JavaScript注释直接把配置嵌入到JS文件中。 配置文件：使用下面任一的文件来为全部的目录和它的子目录指定配置信息 javascript：使用.eslintrc.js文件并导出一个包含配置的对象。 YAML：.eslintrc.yaml或者.eslintrc.yml JSON：.eslintrc.json，并且此文件允许使用JS形式的注释 废弃的用法：.eslintrc，此文件可以是JSON或者YAML package.json：在package.json文件中创建eslintConfig属性，所有的配置包含在此属性中 这些文件的优先级则是按照以上出现的顺序（.eslintrc.js &gt; .eslintrc.yaml &gt; .eslintrc.yml &gt; .eslintrc.json&gt; .eslintrc &gt; package.json） 可以被配置的信息主要分为3类： Environments：你的 javascript 脚步将要运行在什么环境（如：nodejs，browser，commonjs等）中。 Globals：执行代码时脚步需要访问的额外全局变量。 Rules：开启某些规则，也可以设置规则的等级。 安装yarn add eslint 或者全局安装 yarn global add eslint 规则配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515&#123; // 环境定义了预定义的全局变量。 "env": &#123; //环境定义了预定义的全局变量。更多在官网查看 "browser": true, "node": true, "commonjs": true, "amd": true, "es6":true, "mocha":true &#125;, // JavaScript 语言选项 "parserOptions": &#123; // ECMAScript 版本 "ecmaVersion": 6, "sourceType": "script",//module // 想使用的额外的语言特性: "ecmaFeatures": &#123; // 允许在全局作用域下使用 return 语句 "globalReturn":true, // impliedStric "impliedStrict":true, // 启用 JSX "jsx":true &#125; &#125;, /** * "off" 或 0 - 关闭规则 * "warn" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出), * "error" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) */ "rules": &#123; //////////////// // 可能的错误 // //////////////// // 禁止条件表达式中出现赋值操作符 "no-cond-assign": 2, // 禁用 console "no-console": 0, // 禁止在条件中使用常量表达式 // if (false) &#123; // doSomethingUnfinished(); // &#125; //cuowu "no-constant-condition": 2, // 禁止在正则表达式中使用控制字符 ：new RegExp("\x1f") "no-control-regex": 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 "comma-dangle": [1, "always-multiline"], // 禁用 debugger "no-debugger": 2, // 禁止 function 定义中出现重名参数 "no-dupe-args": 2, // 禁止对象字面量中出现重复的 key "no-dupe-keys": 2, // 禁止重复的 case 标签 "no-duplicate-case": 2, // 禁止空语句块 "no-empty": 2, // 禁止在正则表达式中使用空字符集 (/^abc[]/) "no-empty-character-class": 2, // 禁止对 catch 子句的参数重新赋值 "no-ex-assign": 2, // 禁止不必要的布尔转换 "no-extra-boolean-cast": 2, // 禁止不必要的括号 //(a * b) + c;//报错 "no-extra-parens": 0, // 禁止不必要的分号 "no-extra-semi": 2, // 禁止对 function 声明重新赋值 "no-func-assign": 2, // 禁止在嵌套的块中出现 function 或 var 声明 "no-inner-declarations": [2, "functions"], // 禁止 RegExp 构造函数中无效的正则表达式字符串 "no-invalid-regexp": 2, // 禁止在字符串和注释之外不规则的空白 "no-irregular-whitespace": 2, // 禁止在 in 表达式中出现否定的左操作数 "no-negated-in-lhs": 2, // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math(); "no-obj-calls": 2, // 禁止直接使用 Object.prototypes 的内置属性 "no-prototype-builtins":0, // 禁止正则表达式字面量中出现多个空格 "no-regex-spaces": 2, // 禁用稀疏数组 "no-sparse-arrays": 2, // 禁止出现令人困惑的多行表达式 "no-unexpected-multiline": 2, // 禁止在return、throw、continue 和 break语句之后出现不可达代码 /* function foo() &#123; return true; console.log("done"); &#125;//错误 */ "no-unreachable": 2, // 要求使用 isNaN() 检查 NaN "use-isnan": 2, // 强制使用有效的 JSDoc 注释 "valid-jsdoc": 1, // 强制 typeof 表达式与有效的字符串进行比较 // typeof foo === "undefimed" 错误 "valid-typeof": 2, ////////////// // 最佳实践 // ////////////// // 定义对象的set存取器属性时，强制定义get "accessor-pairs": 2, // 强制数组方法的回调函数中有 return 语句 "array-callback-return":0, // 强制把变量的使用限制在其定义的作用域范围内 "block-scoped-var": 0, // 限制圈复杂度，也就是类似if else能连续接多少个 "complexity": [2, 9], // 要求 return 语句要么总是指定返回的值，要么不指定 "consistent-return": 0, // 强制所有控制语句使用一致的括号风格 "curly": [2, "all"], // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告 "default-case": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 "dot-location": [2, "property"], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;"allowKeywords": false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;"allowPattern": "^[a-z]+(_[a-z]+)+$"&#125;] "dot-notation": [2, &#123; "allowKeywords": false &#125;], // 使用 === 替代 == allow-null允许null和undefined== "eqeqeq": [2, "allow-null"], // 要求 for-in 循环中有一个 if 语句 "guard-for-in": 2, // 禁用 alert、confirm 和 prompt "no-alert": 0, // 禁用 arguments.caller 或 arguments.callee "no-caller": 2, // 不允许在 case 子句中使用词法声明 "no-case-declarations":2, // 禁止除法操作符显式的出现在正则表达式开始的位置 "no-div-regex": 2, // 禁止 if 语句中有 return 之后有 else "no-else-return": 0, // 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。 "no-empty-function":2, // 禁止使用空解构模式no-empty-pattern "no-empty-pattern":2, // 禁止在没有类型检查操作符的情况下与 null 进行比较 "no-eq-null": 1, // 禁用 eval() "no-eval": 2, // 禁止扩展原生类型 "no-extend-native": 2, // 禁止不必要的 .bind() 调用 "no-extra-bind": 2, // 禁用不必要的标签 "no-extra-label:":0, // 禁止 case 语句落空 "no-fallthrough": 2, // 禁止数字字面量中使用前导和末尾小数点 "no-floating-decimal": 2, // 禁止使用短符号进行类型转换(!!fOO) "no-implicit-coercion":0, // 禁止在全局范围内使用 var 和命名的 function 声明 "no-implicit-globals":1, // 禁止使用类似 eval() 的方法 "no-implied-eval": 2, // 禁止 this 关键字出现在类和类对象之外 "no-invalid-this":0, // 禁用 __iterator__ 属性 "no-iterator": 2, // 禁用标签语句 "no-labels": 2, // 禁用不必要的嵌套块 "no-lone-blocks": 2, // 禁止在循环中出现 function 声明和表达式 "no-loop-func":1, // 禁用魔术数字(3.14什么的用常量代替) "no-magic-numbers":[1,&#123; "ignore": [0,-1,1] &#125;], // 禁止使用多个空格 "no-multi-spaces": 2, // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串 "no-multi-str": 2, // 禁止对原生对象赋值 "no-native-reassign": 2, // 禁止在非赋值或条件语句中使用 new 操作符 "no-new": 2, // 禁止对 Function 对象使用 new 操作符 "no-new-func": 0, // 禁止对 String，Number 和 Boolean 使用 new 操作符 "no-new-wrappers": 2, // 禁用八进制字面量 "no-octal": 2, // 禁止在字符串中使用八进制转义序列 "no-octal-escape": 2, // 不允许对 function 的参数进行重新赋值 "no-param-reassign": 0, // 禁用 __proto__ 属性 "no-proto": 2, // 禁止使用 var 多次声明同一变量 "no-redeclare": 2, // 禁用指定的通过 require 加载的模块 "no-return-assign": 0, // 禁止使用 javascript: url "no-script-url": 0, // 禁止自我赋值 "no-self-assign":2, // 禁止自身比较 "no-self-compare": 2, // 禁用逗号操作符 "no-sequences": 2, // 禁止抛出非异常字面量 "no-throw-literal": 2, // 禁用一成不变的循环条件 "no-unmodified-loop-condition":2, // 禁止出现未使用过的表达式 "no-unused-expressions": 0, // 禁用未使用过的标签 "no-unused-labels":2, // 禁止不必要的 .call() 和 .apply() "no-useless-call":2, // 禁止不必要的字符串字面量或模板字面量的连接 "no-useless-concat":2, // 禁用不必要的转义字符 "no-useless-escape":0, // 禁用 void 操作符 "no-void": 0, // 禁止在注释中使用特定的警告术语 "no-warning-comments": 0, // 禁用 with 语句 "no-with": 2, // 强制在parseInt()使用基数参数 "radix": 2, // 要求所有的 var 声明出现在它们所在的作用域顶部 "vars-on-top": 0, // 要求 IIFE 使用括号括起来 "wrap-iife": [2, "any"], // 要求或禁止 “Yoda” 条件 "yoda": [2, "never"], // 要求或禁止使用严格模式指令 "strict": 0, ////////////// // 变量声明 // ////////////// // 要求或禁止 var 声明中的初始化(初值) "init-declarations":0, // 不允许 catch 子句的参数与外层作用域中的变量同名 "no-catch-shadow": 0, // 禁止删除变量 "no-delete-var": 2, // 不允许标签与变量同名 "no-label-var": 2, // 禁用特定的全局变量 "no-restricted-globals":0, // 禁止 var 声明 与外层作用域的变量同名 "no-shadow": 0, // 禁止覆盖受限制的标识符 "no-shadow-restricted-names": 2, // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到 "no-undef": 2, // 禁止将变量初始化为 undefined "no-undef-init": 2, // 禁止将 undefined 作为标识符 "no-undefined": 0, // 禁止出现未使用过的变量 "no-unused-vars": [2, &#123; "vars": "all", "args": "none" &#125;], // 不允许在变量定义之前使用它们 "no-use-before-define": 0, ////////////////////////// // Node.js and CommonJS // ////////////////////////// // require return statements after callbacks "callback-return":0, // 要求 require() 出现在顶层模块作用域中 "global-require": 1, // 要求回调函数中有容错处理 "handle-callback-err": [2, "^(err|error)$"], // 禁止混合常规 var 声明和 require 调用 "no-mixed-requires": 0, // 禁止调用 require 时使用 new 操作符 "no-new-require": 2, // 禁止对 __dirname 和 __filename进行字符串连接 "no-path-concat": 0, // 禁用 process.env "no-process-env": 0, // 禁用 process.exit() "no-process-exit": 0, // 禁用同步方法 "no-sync": 0, ////////////// // 风格指南 // ////////////// // 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 "array-bracket-spacing": [2, "never"], // 禁止或强制在单行代码块中使用空格(禁用) "block-spacing":[1,"never"], //强制使用一致的缩进 第二个参数为 "tab" 时，会使用tab， // if while function 后面的&#123;必须与if在同一行，java风格。 "brace-style": [2, "1tbs", &#123; "allowSingleLine": true &#125;], // 双峰驼命名格式 "camelcase": 2, // 控制逗号前后的空格 "comma-spacing": [2, &#123; "before": false, "after": true &#125;], // 控制逗号在行尾出现还是在行首出现 (默认行尾) // http://eslint.org/docs/rules/comma-style "comma-style": [2, "last"], //"SwitchCase" (默认：0) 强制 switch 语句中的 case 子句的缩进水平 // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always "computed-property-spacing": [2, "never"], // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,"that"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 "consistent-this": [1,"that"], // 强制使用命名的 function 表达式 "func-names": 0, // 文件末尾强制换行 "eol-last": 2, "indent": [2, 4, &#123; "SwitchCase": 1 &#125;], // 强制在对象字面量的属性中键和值之间使用一致的间距 "key-spacing": [2, &#123; "beforeColon": false, "afterColon": true &#125;], // 强制使用一致的换行风格 "linebreak-style": [1,"unix"], // 要求在注释周围有空行 ( 要求在块级注释之前有一空行) "lines-around-comment": [1,&#123;"beforeBlockComment":true&#125;], // 强制一致地使用函数声明或函数表达式，方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, "declaration"] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, "expression"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, "declaration", &#123; "allowArrowFunctions": true &#125;] "func-style": 0, // 强制回调函数最大嵌套深度 5层 "max-nested-callbacks": [1,5], // 禁止使用指定的标识符 "id-blacklist":0, // 强制标识符的最新和最大长度 "id-length":0, // 要求标识符匹配一个指定的正则表达式 "id-match":0, // 强制在 JSX 属性中一致地使用双引号或单引号 "jsx-quotes":0, // 强制在关键字前后使用一致的空格 (前后腰需要) "keyword-spacing":2, // 强制一行的最大长度 "max-len":[1,200], // 强制最大行数 "max-lines":0, // 强制 function 定义中最多允许的参数数量 "max-params":[1,7], // 强制 function 块最多允许的的语句数量 "max-statements":[1,200], // 强制每一行中所允许的最大语句数量 "max-statements-per-line":0, // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。） "new-cap": [2, &#123; "newIsCap": true, "capIsNew": false &#125;], // 要求调用无参构造函数时有圆括号 "new-parens": 2, // 要求或禁止 var 声明语句后有一行空行 "newline-after-var": 0, // 禁止使用 Array 构造函数 "no-array-constructor": 2, // 禁用按位运算符 "no-bitwise":0, // 要求 return 语句之前有一空行 "newline-before-return":0, // 要求方法链中每个调用都有一个换行符 "newline-per-chained-call":1, // 禁用 continue 语句 "no-continue": 0, // 禁止在代码行后使用内联注释 "no-inline-comments": 0, // 禁止 if 作为唯一的语句出现在 else 语句中 "no-lonely-if": 0, // 禁止混合使用不同的操作符 "no-mixed-operators":0, // 不允许空格和 tab 混合缩进 "no-mixed-spaces-and-tabs": 2, // 不允许多个空行 "no-multiple-empty-lines": [2, &#123; "max": 2 &#125;], // 不允许否定的表达式 "no-negated-condition":0, // 不允许使用嵌套的三元表达式 "no-nested-ternary": 0, // 禁止使用 Object 的构造函数 "no-new-object": 2, // 禁止使用一元操作符 ++ 和 -- "no-plusplus":0, // 禁止使用特定的语法 "no-restricted-syntax":0, // 禁止 function 标识符和括号之间出现空格 "no-spaced-func": 2, // 不允许使用三元操作符 "no-ternary": 0, // 禁用行尾空格 "no-trailing-spaces": 2, // 禁止标识符中有悬空下划线_bar "no-underscore-dangle": 0, // 禁止可以在有更简单的可替代的表达式时使用三元操作符 "no-unneeded-ternary": 2, // 禁止属性前有空白 "no-whitespace-before-property":0, // 强制花括号内换行符的一致性 "object-curly-newline":0, // 强制在花括号中使用一致的空格 "object-curly-spacing": 0, // 强制将对象的属性放在不同的行上 "object-property-newline":0, // 强制函数中的变量要么一起声明要么分开声明 "one-var": [2, &#123; "initialized": "never" &#125;], // 要求或禁止在 var 声明周围换行 "one-var-declaration-per-line":0, // 要求或禁止在可能的情况下要求使用简化的赋值操作符 "operator-assignment": 0, // 强制操作符使用一致的换行符 "operator-linebreak": [2, "after", &#123; "overrides": &#123; "?": "before", ":": "before" &#125; &#125;], // 要求或禁止块内填充 "padded-blocks": 0, // 要求对象字面量属性名称用引号括起来 "quote-props": 0, // 强制使用一致的反勾号、双引号或单引号 "quotes": [2, "single", "avoid-escape"], // 要求使用 JSDoc 注释 "require-jsdoc":1, // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，） "semi": [2, "always"], // 强制分号之前和之后使用一致的空格 "semi-spacing": 0, // 要求同一个声明块中的变量按顺序排列 "sort-vars": 0, // 强制在块之前使用一致的空格 "space-before-blocks": [2, "always"], // 强制在 function的左括号之前使用一致的空格 "space-before-function-paren": [2, "always"], // 强制在圆括号内使用一致的空格 "space-in-parens": [2, "never"], // 要求操作符周围有空格 "space-infix-ops": 2, // 强制在一元操作符前后使用一致的空格 "space-unary-ops": [2, &#123; "words": true, "nonwords": false &#125;], // 强制在注释中 // 或 /* 使用一致的空格 "spaced-comment": [2, "always", &#123; "markers": ["global", "globals", "eslint", "eslint-disable", "*package", "!"] &#125;], // 要求或禁止 Unicode BOM "unicode-bom": 0, // 要求正则表达式被括号括起来 "wrap-regex": 0, ////////////// // ES6.相关 // ////////////// // 要求箭头函数体使用大括号 "arrow-body-style": 2, // 要求箭头函数的参数使用圆括号 "arrow-parens": 2, "arrow-spacing":[2,&#123; "before": true, "after": true &#125;], // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 "constructor-super": 0, // 强制 generator 函数中 * 号周围使用一致的空格 "generator-star-spacing": [2, &#123; "before": true, "after": true &#125;], // 禁止修改类声明的变量 "no-class-assign":2, // 不允许箭头功能，在那里他们可以混淆的比较 "no-confusing-arrow":0, // 禁止修改 const 声明的变量 "no-const-assign":2, // 禁止类成员中出现重复的名称 "no-dupe-class-members":2, // 不允许复制模块的进口 "no-duplicate-imports":0, // 禁止 Symbol 的构造函数 "no-new-symbol":2, // 允许指定模块加载时的进口 "no-restricted-imports":0, // 禁止在构造函数中，在调用 super() 之前使用 this 或 super "no-this-before-super": 2, // 禁止不必要的计算性能键对象的文字 "no-useless-computed-key":0, // 要求使用 let 或 const 而不是 var "no-var": 0, // 要求或禁止对象字面量中方法和属性使用简写语法 "object-shorthand": 0, // 要求使用箭头函数作为回调 "prefer-arrow-callback":0, // 要求使用 const 声明那些声明后不再被修改的变量 "prefer-const": 0, // 要求在合适的地方使用 Reflect 方法 "prefer-reflect":0, // 要求使用扩展运算符而非 .apply() "prefer-spread":0, // 要求使用模板字面量而非字符串连接 "prefer-template":0, // Suggest using the rest parameters instead of arguments "prefer-rest-params":0, // 要求generator 函数内有 yield "require-yield":0, // enforce spacing between rest and spread operators and their expressions "rest-spread-spacing":0, // 强制模块内的 import 排序 "sort-imports":0, // 要求或禁止模板字符串中的嵌入表达式周围空格的使用 "template-curly-spacing":1, // 强制在 yield* 表达式中 * 周围使用空格 "yield-star-spacing":2 &#125;&#125; prettierprettier是一个代码格式化工具,它支持对JavaScript,JSX,Angular,Vue,Flow,TypeScript,CSS, Less, and SCSS,HTML,JSON,GraphQL,Markdown,including GFM and MDX,YAML格式的代码格式化Prettier提供了一套默认的配置，那么如何修改配置项符合我们自己的代码规范呢，有三种方法可以做到 .prettierrc 文件 prettier.config.js 文件 package.json 中配置prettier属性安装123yarn add prettier --dev --exact# or globallyyarn global add prettier 规则配置123456789101112131415161718&#123; &quot;printWidth&quot;: &quot;80&quot;, // 一行的字符数，如果超过会进行换行 &quot;tabWidth&quot;: &quot;2&quot;, // 一个tab代表几个空格数 &quot;useTabs&quot;: &quot;false&quot;, // 是否使用tab替换空格 &quot;semi&quot;: &quot;true&quot;, // 是否在每句末尾添加分号 &quot;singleQuote&quot;: &quot;false&quot;, // 字符串使用单引号替代双引号 &quot;jsxSingleQuote&quot;: &quot;false&quot;, // jsx语法中是否使用单引号代替双引号 &quot;trailingComma&quot;: &quot;none&quot;, // 是否使用尾逗号，有三个可选值&quot;&lt;none|es5|all&gt;&quot; &quot;bracketSpacing&quot;: true, // 对象大括号直接是否有空格，默认为true，效果：&#123; foo: bar &#125; &quot;jsxBracketSameLine&quot;: &quot;false&quot;, // 将多行JSX元素的&gt;放在最后一行的末尾，而不是单独放在下一行（不适用于自闭元素）。 &quot;arrowParens&quot;: &quot;avoid&quot;, // 在单个箭头函数参数周围加上括号。&quot;&lt;avoid|always&gt;&quot; &quot;rangeStart&quot;: &lt;int&gt;, // 仅格式化文件从&lt;位置&gt;开始, 默认 0 rangeEnd: &lt;int&gt;, // 仅格式化文件从&lt;位置&gt;结束 默认 Infinity &quot;parser&quot;: &quot;babylon&quot;, // 代码的解析引擎，默认为babylon，与babel相同。 &quot;filepath&quot;: &quot;&lt;string&gt;&quot;, // 指定用于推断要使用的解析器的文件名。 &quot;requirePragma&quot;: &lt;bool&gt;, // 是否在被格式化文件开头添加注释 &quot;insertPragma&quot;: &lt;bool&gt;, // 使用@format标记向开头添加换行符。&#125; 更多配置规则： 配合ESLint检测代码风格eslint-plugin-prettiereslint-plugin-prettier插件会调用prettier对你的代码风格进行检查，其原理是先使用prettier对你的代码进行格式化，然后与格式化之前的代码进行对比，如果过出现了不一致，这个地方就会被prettier进行标记。 配置1234567//.eslintrc.js&#123; &quot;plugins&quot;: [&quot;prettier&quot;], &quot;rules&quot;: &#123; &quot;prettier/prettier&quot;: &quot;error&quot; &#125;&#125; pre-commitpre-commit钩子可以在 git commits 之前运行一段脚本比如在commit代码之前运行eslint，校验失败则代码提交失败，校验成功则允许提交代码 安装npm install --save-dev pre-commit npm scripts配置12345678&#123;"scripts": &#123; "dev": "webpack-dev-server &amp; npm run format", "precommit-msg": "echo 'Pre-commit checks.........' &amp;&amp; exit 0", "lint": "eslint --ext .js --ext .jsx src" &#125;, "pre-commit": ["precommit-msg", "lint"]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建微前端架构]]></title>
    <url>%2Fblog%2F2019%2F09%2F12%2F%E6%90%AD%E5%BB%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[什么是微前端微前端是一种类似于微服务的架构,它将微服务的理念应用于浏览器端,即将单页面前端应用由单一应用转变为把多个小型前端应用聚合为一的应用。各个前端应用还可以独立开发、独立部署。同时,它们也可以进行并行开发—这些组件可以通过NPM,GIT或者SVN来管理。 微前端架构特点 应用自治,即每个子应用之间不存在依赖关系,替换其中一个子应用而整体不受影响 单一职责,即微前端架构应该满足单一职责的原则 技术栈无关,即每个子应用可以用不同的前端框架去编写 微前端技术拆分方式1.路由分发式通过HTTP服务器的反向代理功能,将请求路由映射到对应的应用上 2.前端微服务化在不同的框架上设计通信和加载机制,以在一个页面内加载对应的应用 3.微应用通过软件工程的方式,在部署构建环境中,把多个独立的应用组合成一个应用 4.微件化将业务功能拆分成独立的chunk代码,加载即可运行 5.前端容器化iframe 6.应用组件化Web Components技术 前端微服务化这里我们将使用第二种方式,使用前端微服务化的方式将基于create-react-app脚手架搭建的react应用以及vue-cli搭建的vue应用合并在一个基座应用上,做到子应用可以独立开发,分别部署的同时也能做到合并在一起成为一个聚合应用 普通SPA对比前端微服务化普通单体应用 微前端架构 基座模式在这里,我们将通过一个主应用，来管理其它子应用,它主要实现了以下的功能 应用发现。让主应用可以寻找到其它应用。 应用注册。即提供新的微前端应用，向应用注册表注册的功能。 第三方应用注册。即让第三方应用，可以接入到系统中。 访问权限等相关配置。 创建主应用single-spasingle-spa是一款专为微前端实现设计的框架github地址: https://github.com/CanopyTax/single-spa qiankunqiankun是蚂蚁金服为其底层前端框架umi开发的,基于single-spa实现的,更适用于生产的微前端框架github地址: https://github.com/umijs/qiankun 注册基座你的基座应用可以用任何脚手架搭建,比如webpack或者parcel首先yarn add qiankunindex.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; registerMicroApps, start &#125; from 'qiankun';import react from 'react'import ReactDOM from 'react-dom'function Framework() &#123; function goto(title, href) &#123; window.history.pushState(&#123;&#125;, title, href); &#125; return ( &lt;header&gt; &lt;nav&gt; &lt;ol&gt; &lt;li&gt;&lt;a onClick=&#123;() =&gt; goto('react app', '/react')&#125;&gt;react&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a onClick=&#123;() =&gt; goto('vue app', '/vue')&#125;&gt;vue&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/nav&gt; &lt;/header&gt; )&#125;function render(&#123; appContent, loading &#125;) &#123; const container = document.getElementById('container'); ReactDOM.render(&lt;Framework loading=&#123;loading&#125; content=&#123;appContent&#125;/&gt;, container);&#125;function genActiveRule(routerPrefix) &#123; return (location) =&gt; location.pathname.startsWith(routerPrefix);&#125;registerMicroApps( [ &#123; name: 'react app', // app name registered entry: '//localhost:3000', render, activeRule: genActiveRule('/react') &#125;, &#123; name: 'vue app', entry: `//localhost:8080`, render, activeRule: genActiveRule('/vue') &#125;, ],);start(&#123; prefetch: true, jsSandbox: true &#125;) 这里,Framework是你的基座框架,使用的是react的方式实现,也可以使用vue,angular,下面给出vue的写法,主要是render函数的区别12345678910111213141516171819202122232425let app = nullfunction render(&#123; appContent, loading &#125;) &#123; if (!app) &#123; app = new Vue(&#123; el: '#container', data() &#123; return &#123; content: appContent, loading, &#125;; &#125;, render(h) &#123; return h(Framework, &#123; props: &#123; content: this.content, loading: this.loading, &#125;, &#125;); &#125;, &#125;); &#125; else &#123; app.content = appContent; app.loading = loading; &#125;&#125; genActiveRule方法用于基座匹配路由对应的子应用,返回的是布尔值registerMicroApps注册子应用,参数是一个数组,每个数组成员对象都有四个属性,分别是name,entry,render,activeRule,其中,entry是子应用部署所对应的地址最后,别忘了运行start 这样我们的基座就写好,下面我们来改造一个使用vue-cli脚手架搭建的vue项目,使其成为一个微前端子应用 子应用生命周期上面基座中被注册的子应用如何被基座进行挂载以及监听呢,就需要子应用设置生命周期方法 子应用生命周期lifecycles生命周期函数是single-spa将在已注册的应用程序上调用的函数或函数数组。single-spa通过从已注册应用程序的主文件中查找特定的命名导出来调用它们single-spa lifecycles 设置生命周期那么在哪里设置呢,需要在子应用的入口文件处设置,spa项目一般就是/src目录下的index.js文件一般在入口文件中,我们都会进行将实例挂载到dom上的操作,首先,我们就要将这一部分内容注释,基座会调用对应生命周期方法来实例化子应用1234567891011121314151617181920212223//index.jsexport async function bootstrap() &#123; console.log('vue app bootstraped');&#125;export async function mount(props) &#123; console.log(props); instance = new Vue(&#123; el: '#vueRoot', render: h =&gt; h(App), &#125;)&#125;export async function unmount() &#123; ReactDOM.unmountComponentAtNode(document.getElementById('vueRoot'));&#125;// 不执行实例化方法/* new Vue(&#123; el: '#vueRoot', render: h =&gt; h(App), &#125;) */ 入口文件不会实例化到dom对象,而是会导出相应的生命周期方法,由基座来进行对应的生命周期操作 webpack的相关配置注意项上面的配置基本算是已经完成了,但是还是不够的,在实际开发中会遇到很多问题,这在框架文档中并不会列出来,因为大部分问题并不属于框架本身的问题,这个时候就要根据报错信息一一排查下面是笔者在实践中遇到问题的解决办法 cra(create-react-app)配置如果使用cra搭建的脚手架,一般会用到customize-cra这个辅助工具,来完成webpack的配置,github地址:https://github.com/arackaf/customize-cra下面给出示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const &#123; override, fixBabelImports, addLessLoader, useEslintRc, addDecoratorsLegacy, overrideDevServer,&#125; = require(&quot;customize-cra&quot;)const variables = require(&quot;./src/styles/variables&quot;)const antdThemes = require(&quot;./src/styles/antd&quot;)const themes = &#123;&#125;Object.keys(antdThemes).forEach(key =&gt; &#123; themes[&quot;@&quot; + key] = variables[key]&#125;)const rewiredMap = () =&gt; config =&gt; &#123; config.devtool = config.mode === &quot;development&quot; ? &quot;cheap-module-source-map&quot; : false return config&#125;const devServerConfig = () =&gt; config =&gt; &#123; return &#123; ...config, before(app) &#123; app.use((req, res, next) =&gt; &#123; res.append(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;) next() &#125;) &#125; &#125;&#125;const outputChange = () =&gt; config =&gt; &#123; config.output.library = &quot;packageName&quot; config.output.libraryTarget = &quot;umd&quot; config.output.jsonpFunction = &quot;webpackJsonp_packageName&quot; config.output.umdNamedDefine = true config.output.publicPath = &apos;http://localhost:3000/&apos;// config.optimization = &#123;&#125; return config&#125;module.exports = &#123; webpack: override( outputChange(), // disableChunk(), fixBabelImports(&quot;import&quot;, &#123; libraryName: &quot;antd&quot;, libraryDirectory: &quot;es&quot;, style: true &#125;), addLessLoader(&#123; javascriptEnabled: true, modifyVars: themes, data: Object.keys(variables) .map(key =&gt; `@$&#123;key&#125;:$&#123;variables[key]&#125;`) .join(`\n`), localIdentName: &quot;[local]--[hash:base64:5]&quot; &#125;), addDecoratorsLegacy(), useEslintRc(), rewiredMap() ), devServer: overrideDevServer( devServerConfig() )&#125; webpack导出umd首先,需要将webpack的导出选项设置为umd通用模式umd原理:1.先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。2.再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。3.前两个都不存在，则将模块公开到全局（window或global）。12345output: &#123; library: packageName, libraryTarget: &apos;umd&apos;, jsonpFunction: `webpackJsonp_$&#123;packageName&#125;`,&#125; 跨域由于主服务与子服务是运行在不同的端口下,所以需要解决跨域问题1234567// webpack-dev-server设置示例before(app) &#123; app.use((req, res, next) =&gt; &#123; res.append(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;) next() &#125;) &#125; 请求地址问题需要将子项目的webpack的publicPath配置项设为绝对地址,这样在请求资源时不会因为路径而导致子应用died 子项目css样式隔离CSS Modules如果使用antd,https://pro.ant.design/docs/style-cn]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Github WebHooks监听提交实现hexo自动部署]]></title>
    <url>%2Fblog%2F2019%2F09%2F02%2FWebHook%E7%9B%91%E5%90%AC%E6%8F%90%E4%BA%A4%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[WebhooksWebhooks允许在发生特定事件时通知外部服务。当指定的事件发生时，将向设置好的URL地址发送POST请求。 在GitHub中设置webhooks首先进入项目的设置页面,在左侧找到Webhooks选项,点击add进入新增设置 首先设置Payload URL,这是你的服务器地址,每当有提交动作就会像这个地址发送post请求 Content type可以设置表单或者json格式 Secret密钥,用于服务器验证请求是否有Github服务器发送 所有设置完毕后,就可以进行下一步 服务器监听这里推荐使用github-webhook-handler这个库,可以很方便帮助我们完成服务端的配置示例代码1234567891011121314151617181920212223242526272829var http = require('http')var createHandler = require('github-webhook-handler')var handler = createHandler(&#123;path: '这里填写在github上配置的路径地址', secret: '这里填写上面项目上配置的密钥'&#125;)const &#123;exec&#125; = require('child_process') // 执行本地命令http.createServer(function(req, res) &#123; handler(req, res, function(err) &#123; res.statusCode = 404 res.end('no such location') &#125;)&#125;).listen('配置的端口')handler.on('error', function(err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function(event) &#123; console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref) exec('cd /www/wwwroot/default/blog &amp;&amp; git pull', (err, stdout, stderr) =&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log('updated success') &#125; &#125;)&#125;) 结束这样,在服务端部署好这个小的程序后(注意开放相关端口),每次在本地执行hexo g -d命令后,服务端接收到钩子信息就会自动从master分支拉取最新的代码,实现自动更新]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】如何用puppeteer通过slider滑块认证]]></title>
    <url>%2Fblog%2F2019%2F08%2F22%2F%5B%E7%BF%BB%E8%AF%91%5D%E5%A6%82%E4%BD%95%E7%94%A8puppeteer%E9%80%9A%E8%BF%87slider%E6%BB%91%E5%9D%97%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[Photo by James Pond on Unsplash 垃圾邮件对于网站所有者来说是个大问题。另一方面，划块验证让我发疯，他们对用户体验不太友好。 划块验证虽然很糟糕但是我们还是要面对它,有很多种方法可以人机验证,但是他们一般来说都不太好。 近年来爬虫变得越来越智能并且网站很难去识别,在拥有大量的时间以及足够的资源后,我们几乎可以通过任何人机验证。现在有插件可以防止使用puppeteer被检测并解决人机验证,甚至出现了专门的公司。我们无法检测到被puppeteer控制的无头chrome浏览器。 有些网站使用了滑块验证来作为人机验证的一种方案,但是为什么有人会使用这么简单的东西来绕过它: 大多数爬虫不执行js代码 用户体验更好 滑块的方式天然适合手机用户 所以,滑块验证对于用户来说是美好且亲切的,但是如果只有滑块验证的话那就象手拿木棒赤裸地进入战场了。 让我们来通过滑块验证吧! 滑动提交有一种jquery插件是专门为这种防止垃圾邮件的表单服务的 首先我们计算出滑块区域的边界信息,为了移动滑块,我们要做以下这些事: 把鼠标放在要操作元素的中心 按下鼠标 移动 在合适的位置松开鼠标 12345678910111213141516171819202122232425262728293031const puppeteer = require('puppeteer')async function run() &#123; const browser = await puppeteer.launch(&#123; headless: false, defaultViewport: &#123; width: 1366, height: 768 &#125; &#125;) const page = await browser.newPage() await page.goto('http://kthornbloom.com/slidetosubmit/') await page.type('input[name="name"]', 'Puppeteer Bot') await page.type('input[name="email"]', 'js@automation.com') let sliderElement = await page.$('.slide-submit') let slider = await sliderElement.boundingBox() let sliderHandle = await page.$('.slide-submit-thumb') let handle = await sliderHandle.boundingBox() await page.mouse.move(handle.x + handle.width / 2, handle.y + handle.height / 2) await page.mouse.down() await page.mouse.move(handle.x + slider.width, handle.y + handle.height / 2, &#123; steps: 10 &#125;) await page.mouse.up() await page.waitFor(3000) // success! await browser.close()&#125;run() Dipbit注册滑块验证Dipbit是一个数字货币兑换网站。登录页面和注册页面都有滑块验证。Dipbit就要显得聪明一点了,所以我们要增加一些代码来隐藏puppeteer的执行1234567891011121314151617181920212223242526272829303132333435363738const puppeteer = require('puppeteer')async function run() &#123; const browser = await puppeteer.launch(&#123; headless: false, defaultViewport: &#123; width: 1366, height: 768 &#125; &#125;) const page = await browser.newPage() await page.evaluateOnNewDocument(() =&gt; &#123; Object.defineProperty(navigator, 'webdriver', &#123; get: () =&gt; false //注 检测是否为无头浏览器 &#125;) &#125;) await page.goto('https://www.dipbit.com/auth/login') await page.type('#email', 'js@automation.com') await page.type('#password', 'password123') let sliderElement = await page.$('.slidetounlock') let slider = await sliderElement.boundingBox() let sliderHandle = await page.$('.nc_iconfont.btn_slide') let handle = await sliderHandle.boundingBox() await page.mouse.move(handle.x + handle.width / 2, handle.y + handle.height / 2) await page.mouse.down() await page.mouse.move(handle.x + slider.width, handle.y + handle.height / 2, &#123; steps: 50 &#125;) await page.mouse.up() await page.waitFor(3000) // success! await browser.close()&#125;run() 淘宝淘宝的注册验证和Dipbit相似,唯一的区别就是他的验证表单嵌套在一个iframe的框架中,但对于Puppeteer来说,这不是问题。1234567891011121314151617181920212223242526272829303132333435363738const puppeteer = require('puppeteer')async function run() &#123; const browser = await puppeteer.launch(&#123; headless: false, defaultViewport: &#123; width: 1366, height: 768 &#125; &#125;) const page = await browser.newPage() await page.evaluateOnNewDocument(() =&gt; &#123; Object.defineProperty(navigator, 'webdriver', &#123; get: () =&gt; false &#125;) &#125;) await page.goto('https://world.taobao.com/markets/all/sea/register') let frame = page.frames()[1] await frame.waitForSelector('.nc_iconfont.btn_slide') const sliderElement = await frame.$('.slidetounlock') const slider = await sliderElement.boundingBox() const sliderHandle = await frame.$('.nc_iconfont.btn_slide') const handle = await sliderHandle.boundingBox() await page.mouse.move(handle.x + handle.width / 2, handle.y + handle.height / 2) await page.mouse.down() await page.mouse.move(handle.x + slider.width, handle.y + handle.height / 2, &#123; steps: 50 &#125;) await page.mouse.up() await page.waitFor(3000) // success! await browser.close()&#125;run() 拼图验证我遇到了’滑动验证’vue组件应该对人来说很容易但是对机器不容易此验证方法获取图像，创建2个画布和一个滑块。它使用拼图渲染初始图像。用户将移动滑块和拼图块匹配。当两个部分匹配时，用户应释放滑块并验证结束。这种验证随机化拼图位置来混淆机器人。在此我不想做任何诸如机器学习或者OCR等花哨的东西,所以我只是一点一点的移动并与最初的图片进行比较1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const puppeteer = require('puppeteer')const Rembrandt = require('rembrandt')async function run () &#123; const browser = await puppeteer.launch(&#123; headless: false, defaultViewport: &#123; width: 1366, height: 768 &#125; &#125;) const page = await browser.newPage() let originalImage = '' await page.setRequestInterception(true) page.on('request', request =&gt; request.continue()) page.on('response', async response =&gt; &#123; if (response.request().resourceType() === 'image') originalImage = await response.buffer().catch(() =&gt; &#123;&#125;) &#125;) await page.goto('https://monoplasty.github.io/vue-monoplasty-slide-verify/') const sliderElement = await page.$('.slide-verify-slider') const slider = await sliderElement.boundingBox() const sliderHandle = await page.$('.slide-verify-slider-mask-item') const handle = await sliderHandle.boundingBox() let currentPosition = 0 let bestSlider = &#123; position: 0, difference: 100 &#125; await page.mouse.move(handle.x + handle.width / 2, handle.y + handle.height / 2) await page.mouse.down() while (currentPosition &lt; slider.width - handle.width / 2) &#123; await page.mouse.move( handle.x + currentPosition, handle.y + handle.height / 2 + Math.random() * 10 - 5 ) let sliderContainer = await page.$('.slide-verify') let sliderImage = await sliderContainer.screenshot() const rembrandt = new Rembrandt(&#123; imageA: originalImage, imageB: sliderImage, thresholdType: Rembrandt.THRESHOLD_PERCENT &#125;) let result = await rembrandt.compare() let difference = result.percentageDifference * 100 if (difference &lt; bestSlider.difference) &#123; bestSlider.difference = difference bestSlider.position = currentPosition &#125; currentPosition += 10 &#125; await page.mouse.move(handle.x + bestSlider.position, handle.y + handle.height / 2, &#123; steps: 10 &#125;) await page.mouse.up() await page.waitFor(3000) // success! await browser.close()&#125;run() 以防万一你错过了一个很酷的部分。我将Y轴上的滑块移动随机化以模拟真实的用户鼠标移动😎1234await page.mouse.move( handle.x + currentPosition, handle.y + handle.height / 2 + Math.random() * 10 - 5 ) 以上所有代码都在这个仓库 结论如果网站拥有更好的体验并且可以轻松绕过人机验证，或者网站积极地保护自己免受机器人攻击但是用户体验不佳，这一直是一个两难选择。网站和机器人之间的战争永远不会结束。无论网站采用何种验证方法，有人想出如何绕过它只是时间问题。 原文链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[纯css实现动态天气效果代码]]></title>
    <url>%2Fblog%2F2019%2F08%2F21%2F%E7%BA%AFcss%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%A4%A9%E6%B0%94%E6%95%88%E6%9E%9C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[预览效果 代码html代码1234&lt;div class="weather sunny"&gt;&lt;/div&gt;&lt;div class="weather cloudy"&gt;&lt;/div&gt;&lt;div class="weather rainy"&gt;&lt;/div&gt;&lt;div class="weather snowy"&gt;&lt;/div&gt; css 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180.weather &#123; position: relative; display: inline-block; width: 180px; height: 240px; background: #23b7e5; border-radius: 8px;&#125;.sunny:before &#123; content: ""; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60px; height: 60px; background: #F6D963; border-radius: 50%; box-shadow: 0 0 20px #ff0; z-index: 2;&#125;.sunny:after &#123; content: ""; position: absolute; top: 50%; left: 50%; margin: -45px 0 0 -45px; width: 90px; height: 90px; background: #FFEB3B; clip-path: polygon( 50% 0%, 65.43% 25%, 93.3% 25%, 78.87% 50%, 93.3% 75%, 64.43% 75%, 50% 100%, 35.57% 75%, 6.7% 75%, 21.13% 50%, 6.7% 25%, 35.57% 25%); z-index: 1; animation: sunScale 2s linear infinite;&#125;@keyframes sunScale &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.1); &#125; 100% &#123; transform: scale(1); &#125;&#125;.cloudy:before,.rainy:before,.snowy:before &#123; content: ""; position: absolute; top: 50%; left: 25%; transform: translate(-50%, -50%); width: 36px; height: 36px; background: #fff; border-radius: 50%; box-shadow: #fff 22px -15px 0 6px, #fff 57px -6px 0 2px, #fff 87px 4px 0 -4px, #fff 33px 6px 0 6px, #fff 61px 6px 0 2px, #ccc 29px -23px 0 6px, #ccc 64px -14px 0 2px, #ccc 94px -4px 0 -4px; z-index: 2;&#125;.cloudy:before &#123; animation: cloudMove 2s linear infinite;&#125;@keyframes cloudMove &#123; 0% &#123; transform: translate(-50%, -50%); &#125; 50% &#123; transform: translate(-50%, -60%); &#125; 100% &#123; transform: translate(-50%, -50%); &#125;&#125;.rainy:after &#123; content: ""; position: absolute; top:50%; left: 25%; width: 4px; height: 14px; background: #fff; border-radius: 2px; box-shadow: #fff 25px -10px 0, #fff 50px 0 0, #fff 75px -10px 0, #fff 0 25px 0, #fff 25px 15px 0, #fff 50px 25px 0, #fff 75px 15px 0, #fff 0 50px 0, #fff 25px 40px 0, #fff 50px 50px 0, #fff 75px 40px 0; animation: rainDrop 2s linear infinite; &#125;@keyframes rainDrop &#123; 0% &#123; transform: translate(0, 0) rotate(10deg); &#125; 100% &#123; transform: translate(-4px, 24px) rotate(10deg); box-shadow: #fff 25px -10px 0, #fff 50px 0 0, #fff 75px -10px 0, #fff 0 25px 0, #fff 25px 15px 0, #fff 50px 25px 0, #fff 75px 15px 0, rgba(255, 255, 255, 0) 0 50px 0, rgba(255, 255, 255, 0) 25px 40px 0, rgba(255, 255, 255, 0) 50px 50px 0, rgba(255, 255, 255, 0) 75px 40px 0; &#125;&#125;.snowy:after &#123; content: ""; position: absolute; top:50%; left: 25%; width: 8px; height: 8px; background: #fff; border-radius: 50%; box-shadow: #fff 25px -10px 0, #fff 50px 0 0, #fff 75px -10px 0, #fff 0 25px 0, #fff 25px 15px 0, #fff 50px 25px 0, #fff 75px 15px 0, #fff 0 50px 0, #fff 25px 40px 0, #fff 50px 50px 0, #fff 75px 40px 0; animation: snowDrop 2s linear infinite; &#125;@keyframes snowDrop &#123; 0% &#123; transform: translateY(0); &#125; 100% &#123; transform: translateY(25px); box-shadow: #fff 25px -10px 0, #fff 50px 0 0, #fff 75px -10px 0, #fff 0 25px 0, #fff 25px 15px 0, #fff 50px 25px 0, #fff 75px 15px 0, rgba(255, 255, 255, 0) 0 50px 0, rgba(255, 255, 255, 0) 25px 40px 0, rgba(255, 255, 255, 0) 50px 50px 0, rgba(255, 255, 255, 0) 75px 40px 0; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue transition实现原生页面跳转效果]]></title>
    <url>%2Fblog%2F2019%2F08%2F21%2Ftransition%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%94%9F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[代码使用Vue &lt;transition&gt; 组件过渡 123&lt;transition :name=&quot;this.$store.routeAction&quot;&gt; &lt;router-view/&gt;&lt;/transition&gt; CSS1234567891011121314151617181920212223242526.push-enter-active,.push-leave-active, .pop-enter-active,.pop-leave-active&#123; transition: all 0.4s;&#125;.push-leave-to&#123;transform: translate(-20%,0);&#125;.push-enter &#123; transform: translate(100%, 0);&#125;.push-enter-active &#123; z-index: 10;&#125;.push-leave-active &#123; z-index: 0;&#125;.pop-leave-active &#123; transform: translate(100%, 0); z-index: 11;&#125;.pop-enter&#123; transform: translate(-20%,0);&#125; 效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[chrome快捷键太反人类?不想安装额外插件?那就用TamperMonkey写个脚本]]></title>
    <url>%2Fblog%2F2019%2F07%2F19%2Fchrome%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%AA%E5%8F%8D%E4%BA%BA%E7%B1%BB-%E4%B8%8D%E6%83%B3%E5%AE%89%E8%A3%85%E9%A2%9D%E5%A4%96%E6%8F%92%E4%BB%B6-%E9%82%A3%E5%B0%B1%E7%94%A8TamperMonkey%E5%86%99%E4%B8%AA%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Chrome快捷键对于一天用到将近百余次的ctrl+w的我来说,一直觉得chrome原本的ctrl+w的按键有点别扭,终于在今天忍不住了,开始寻找如何去修改chrome默认的快捷键。在设置里找了一圈,发现没有,无奈google了一下,发现有这么几种办法 安装chrome插件 如Shortkeys等 修改chrome系统文件我综合了一下,发现我只需要实现alt + w关闭浏览器TAB的功能,这么折腾似乎不太经济,突然想到我有安装TamperMonkey油猴插件,于是便想到自己动手写个js脚本完事 TamperMonkeyTamperMonkey是一个浏览器插件,它是一个脚本管理器,通过脚本市场安装第三方js脚本,可以实现非常多的拓展功能,可以就不展开了我们新建一个脚本文件,注意脚本文件开头 match选项表示脚本应用的范围,这里我们应用所有网站12// @match http://*/*// @match https://*/* 编写脚本好了,下面就开始编写我们的脚本,TamperMonkey脚本文件实质就是输出个js IFFE(立即执行函数),脚本内容都编写在里面,我们只需要全局监听onkeydown事件,判断是否同时按下alt + w,然后执行window.close()关闭页面就可以了12345678(function() &#123; window.addEventListener('keydown',function(event)&#123; if (event.altKey &amp;&amp; event.keyCode == 87) &#123; window.location.href = "about:blank" window.close() &#125; &#125;)&#125;)()]]></content>
  </entry>
  <entry>
    <title><![CDATA[收集常用的css代码]]></title>
    <url>%2Fblog%2F2019%2F07%2F11%2F%E6%94%B6%E9%9B%86%E5%B8%B8%E7%94%A8%E7%9A%84css%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[清除默认样式reset 12345678910111213141516171819202122html,body&#123;height:100%;&#125;html,body,h1,h2,h3,h4,h5,h6,div,dl,dt,dd,ul,ol,li,p,blockquote,pre,hr,figure,table,caption,th,td,form,fieldset,legend,input,button,textarea,menu&#123;margin:0;padding:0;&#125;header,footer,section,article,aside,nav,hgroup,address,figure,figcaption,menu,details&#123;display:block;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125;caption,th&#123;text-align:left;font-weight:normal;&#125;html,body,fieldset,img,iframe,abbr&#123;border:0;&#125;i,cite,em,var,address,dfn&#123;font-style:normal;&#125;[hidefocus],summary&#123;outline:0;&#125;li&#123;list-style:none;&#125;h1,h2,h3,h4,h5,h6,small&#123;font-size:100%;&#125;sup,sub&#123;font-size:83%;&#125;pre,code,kbd,samp&#123;font-family:inherit;&#125;q:before,q:after&#123;content:none;&#125;textarea&#123;overflow:auto;resize:none;&#125;label,summary&#123;cursor:default;&#125;a,button&#123;cursor:pointer;&#125;h1,h2,h3,h4,h5,h6,em,strong,b&#123;font-weight:bold;&#125;del,ins,u,s,a,a:hover&#123;text-decoration:none;&#125;body,textarea,input,button,select,keygen,legend&#123;font:12px/1.14 Microsoft YaHei,arial,\5b8b\4f53;color:#333;outline:0;&#125;body&#123;background:#fff;&#125;a,a:hover&#123;color:#333;&#125;*&#123;box-sizing: border-box;&#125; 去除input默认填充的背景颜色 123input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px white inset;&#125; 清除input[type=number]的默认样式 12345678input[type=number] &#123; -moz-appearance:textfield;&#125;input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button &#123; -webkit-appearance: none; margin: 0;&#125; 清除移动端 a 标签等点击区域变色 123*&#123; -webkit-tap-highlight-color: rgba(255, 255, 255, 0);&#125; 清除移动端 input 样式 12345678input&#123; border: none; -moz-appearance:none; -webkit-appearance : none ; /*解决ios上按钮的圆角问题*/ border-radius: 0; /*解决ios上输入框圆角问题*/ outline:medium; /*去掉鼠标点击的默认黄色边框*/ background-color: transparent;&#125; 避免ios滑动滚动条卡顿 123*&#123; -webkit-overflow-scrolling : touch&#125; 滚动条样式 123456789101112131415161718192021222324252627282930.scroll-container &#123; height: 250px; border: 1px solid #ddd; padding: 15px; overflow: auto; .row &#123; margin: 0; line-height: 1.5; &#125; &amp;::-webkit-scrollbar &#123; width: 8px; background: white; &#125; &amp;::-webkit-scrollbar-corner, /* 滚动条角落 */ &amp;::-webkit-scrollbar-thumb, &amp;::-webkit-scrollbar-track &#123; border-radius: 4px; &#125; &amp;::-webkit-scrollbar-corner, &amp;::-webkit-scrollbar-track &#123; /* 滚动条轨道 */ background-color: rgba(180, 160, 120, 0.1); box-shadow: inset 0 0 1px rgba(180, 160, 120, 0.5); &#125; &amp;::-webkit-scrollbar-thumb &#123; /* 滚动条手柄 */ background-color: #00adb5; &#125;&#125; 常用 midea媒体查询 12345678910111213141516171819202122232425262728293031323334353637/* 横屏 */@media screen and (orientation:landscape)&#123; &#125;/* 竖屏 */@media screen and (orientation:portrait)&#123; &#125;/* 窗口宽度&lt;960,设计宽度=768 */@media screen and (max-width:959px)&#123; &#125;/* 窗口宽度&lt;768,设计宽度=640 */@media screen and (max-width:767px)&#123; &#125;/* 窗口宽度&lt;640,设计宽度=480 */@media screen and (max-width:639px)&#123; &#125;/* 窗口宽度&lt;480,设计宽度=320 */@media screen and (max-width:479px)&#123; &#125;/* 设备像素比为2 *//* 常用于1px边框，还应规定 3dppx 的情况 */@media (min-resolution: 2dppx) &#123;&#125;/* windows UI 贴靠 */@media screen and (-ms-view-state:snapped)&#123; &#125;/* 打印 */@media print&#123; &#125; 长文本折行 1234.long-text&#123; white-space: pre-line; word-wrap: break-word;&#125; 文字超出显示省略号单行文字1234567/*注意宽度是必须的*/.article-container &#123; width: 500px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文字 12345678.article-container &#123; display: -webkit-box; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 4; //需要显示的行数 overflow: hidden; text-overflow: ellipsis;&#125; 消除图片下方间隙 通过设置给 img 元素设置 vertical-align: top 消除行内元素的间隙（仅对 img 元素有用 1vertical-align: top; 图文居中 1234&lt;div class="container"&gt; &lt;img src="../../public/images/bg1.jpg"&gt; &lt;span&gt;安能摧眉折腰事权贵，使我不得开心颜&lt;/span&gt;&lt;/div&gt; 123456.container&#123; padding:15px 0; img&#123; vertical-align: middle; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用webpack4配置一个完整的react前端工程]]></title>
    <url>%2Fblog%2F2019%2F06%2F13%2F%E4%BD%BF%E7%94%A8webpack4%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、基础配置1、init1234mkdir webpack-projectcd webpack-projectmkdir srcyarn init 2、安装1234567891011121314yarn add webpack webpack-cli webpack-dev-servertouch webpack.config.js// webpack.config.jsmodule.exports = &#123; mode: "development", entry: ["./src/index.js"], output: &#123; path: path.join(__dirname,'dist'), filename: "bundle.js" &#125;, module: &#123;&#125;, plugins: &#123;&#125;, devServer: &#123;&#125;&#125; 3、安装react123456789yarn add react react-dom react-router-dom// 建立如下的文件目录，并编写安装react和react-router并编写react代码如下|-src│ index.js 主文件├───pages│ Count.jsx -- 实现了一个计数器的功能，点击按钮，会让数字增加，按钮会实时显示在页面上│ Home.jsx -- 一个简单的文字展示└───router index.js -- 路由配置文件，两个页面分别对应两个路由 count和 home 4、babel编译es6,jsx等12345678910111213// @babel/core-babel核心模块 @babel/preset-env-编译ES6等 @babel/preset-react-转换JSXyarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/preset-react// @babel/plugin-transform-runtime: 避免 polyfill 污染全局变量，减小打包体积// @babel/polyfill: ES6 内置方法和函数转化垫片yarn add @babel/polyfill @babel/runtime//module配置&#123; test: /\.jsx?$/, exclude: &apos;/node_modules/&apos;, use: [&#123; loader: &apos;babel-loader&apos; &#125;]&#125; 根目录新建.babelrc文件1234&#123; "presets": ["@babel/preset-env","@babel/preset-react"], "plugins": ["@babel/plugin-transform-runtime"]&#125; 5、按需引入babel-polyfill一般地,安装完@babel/polyfill之后,在入口文件直接import,但这样会有导致引入不需要的语法垫片,导致打包出来的文件过大的问题当配合@babel/preset-env一起使用时,更改.babelrcuseBuiltIns表示只打包项目使用到的123456&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;usage&quot; &#125;, //entry 表示完整引入 &quot;@babel/preset-react&quot;], &quot;plugins&quot;: [&quot;@babel/plugin-transform-runtime&quot;]&#125; 如果没有用到@babel/preset-env时,可以在entry入口导入,但是官方建议还是不要这么做123module.exports = &#123; entry:['@babel/polyfill','./src/index.js']&#125; 6、插件CleanWebpackPlugin每次打包都会在dist生成新的文件,所以需要这个插件在每次打包前删除上次打包好的文件12345yarn add CleanWebpackPluginimport CleanWebpackPlugin from 'clean-webpack-plugin'plugins :[ new CleanWebpackPlugin() ] 7、使用HtmlWebpackPlugin现在我们生成的都是js文件,但是我们还需要html,使用这个插件可以通过设置的模板html生成自动关联js路径的最终的html123456789101112yarn add html-webpack-plugincd srctouch index.html//webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin');plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; filename: 'index.html', // 最终创建的文件名 template: path.join(__dirname, 'src/template.html') // 指定模板路径 &#125;) ] 8、使用dev-tool配置项进行source-map优化webpack中devtool选项用来控制是否生成，以及如何生成 source map。简言之，source map就是帮助我们定位到错误信息位置的文件。正确的配置source map，能够提高开发效率，更快的定位到错误位置。12345//webpack.config.jsmodule.exports = &#123; devtool:'cheap-module-eval-source-map',//线上环境 devtool:'cheap-module-source-map'//测试环境&#125; 9、使用WebpackDevServer配置开发服务器webpack-dev-server是在本地开发部署的一个小型的静态资源服务器,提供实时重载功能123456789101112131415//webpack.config.jsmodule.exports = &#123; devServer: &#123; hot:true, inline:true, contentBase:path.join(__dirname,'dist'), host:'0.0.0.0',//方便局域网访问 port:8080, historyApiFallback: true, // 该选项的作用所有的404都连接到index.html proxy: &#123; // 代理到后端的服务地址，会拦截所有以api开头的请求地址, 解决跨域问题 "/api": "http://xxx.xxx.x.xx:xxxx" &#125; &#125;&#125; 10、使用HotModuleReplacement热更新(HMR)建立了开发环境本地服务器后，当修改内容后，网页会同步刷新，我们现在进入toCount页面 点击按钮，将数字加到一个不为0的数，比如加到6 然后你可以在代码中改变按钮的文字，随便改点东西，会发现，页面刷新后，数字重新变为0这显然不是我们想要的，想要的是，能不能把页面的状态保存了，也就是更改了代码后，页面还是保存了数字为6的状态,也就是局部改变。这时就要用到HotModuleReplacement这个插件12345678910111213141516//webpack.config.jsmodule.exports = &#123; devServer: &#123; hot:true, inline:true, contentBase:path.join(__dirname,'dist'), host:'0.0.0.0',//方便局域网访问 port:8080, historyApiFallback: true, // 该选项的作用所有的404都连接到index.html proxy: &#123; // 代理到后端的服务地址，会拦截所有以api开头的请求地址, 解决跨域问题 "/api": "http://xxx.xxx.x.xx:xxxx" &#125; &#125;, plugins:[new webpack.HotModuleReplacementPlugin()]&#125; 11、react-hot-loader记录react页面留存状态statereact-hot-loader是解决在react开发中的页面留存状态刷新问题1234567891011121314151617181920212223242526272829303132cnpm i react-hot-loader -D // 在主文件里这样写 import React from "react";import ReactDOM from "react-dom";import &#123; AppContainer &#125; from "react-hot-loader";-------------------1、首先引入AppContainreimport &#123; BrowserRouter &#125; from "react-router-dom";import Router from "./router"; /*初始化*/renderWithHotReload(Router);-------------------2、初始化 /*热更新*/if (module.hot) &#123;-------------------3、热更新操作 module.hot.accept("./router/index.js", () =&gt; &#123; const Router = require("./router/index.js").default; renderWithHotReload(Router); &#125;);&#125; function renderWithHotReload(Router) &#123;-------------------4、定义渲染函数 ReactDOM.render( &lt;AppContainer&gt; &lt;BrowserRouter&gt; &lt;Router /&gt; &lt;/BrowserRouter&gt; &lt;/AppContainer&gt;, document.getElementById("app") );&#125; 12、编译css和scss/less12345678910yarn add css-loader style-loader sass-loader node-sass / less-loader //webpack.config.js&#123; test: /\.scss$/, use: [ &quot;style-loader&quot;, // 创建style标签，并将css添加进去 &quot;css-loader&quot;, // 编译css &quot;sass-loader&quot; // 编译scss ]&#125; 13、使用PostCSSPostCSS是一个使用JS插件转换css样式的工具,最常用到的就是Autoprefixer这个插件,但还有许多的插件比如postcss-preset-env,可以使用实验性的css特性,stylelintcss语法检测等1234567891011yarn add postcss-loader//webpack.config.js&#123; test: /\.scss$/, use: [ "style-loader", // 创建style标签，并将css添加进去 "css-loader", // 编译css "postcss-loader", "sass-loader" // 编译scss ]&#125; 14、处理图片123456789101112131415yarn add file-loader url-loader url-loader 解决css等文件中引入图片路径的问题file-loader 当图片较小的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝//webpack.config.js&#123; test: /\.(png|jpg|jpeg|gif|svg)/, use: &#123; loader: 'url-loader', options: &#123; outputPath: 'images/', // 图片输出的路径 limit: 10 * 1024 &#125; &#125;&#125; 15、处理字体1234567891011121314&#123; test: /\.(eot|woff2?|ttf|svg)$/, use: [ &#123; loader: 'url-loader', options: &#123; name: '[name]-[hash:5].min.[ext]', limit: 5000, // fonts file size &lt;= 5KB, use 'base64'; else, output svg file publicPath: 'fonts/', outputPath: 'fonts/' &#125; &#125; ] &#125; webpack优化1、extension,alias对文件路径后缀名优化 extension: 指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配 alias: 配置别名可以加快webpack查找模块的速度12345678resolve: &#123; extension: ["", ".js", ".jsx"], alias: &#123; "@": path.join(__dirname, "src"), pages: path.join(__dirname, "src/pages"), router: path.join(__dirname, "src/router") &#125; &#125; 2、MiniCssExtractPlugin抽取css文件如果不做配置，我们的css是直接打包进js里面的，我们希望能单独生成css文件。 因为单独生成css,css可以和js并行下载，提高页面加载效率12345678910111213141516171819202122yarn add mini-css-extract-plugin//webpack.config.jsconst MiniCssExtractPlugin = require("mini-css-extract-plugin"); &#123; &#123; test: /\.scss$/, use: [ // "style-loader", // b不再需要style-loader要已经分离处理 MiniCssExtractPlugin.loader, "css-loader", // 编译css "postcss-loader", "sass-loader" // 编译scss ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: "[name].css", chunkFilename: "[id].css" &#125;) ]&#125; 3、代码分割按需加载、提取公共代码为什么要实现按需加载？我们现在看到，打包完后，所有页面只生成了一个bundle.js,当我们首屏加载的时候，就会很慢。因为他也下载了别的页面的js了,也就是说，执行完毕之前，页面是完全空白的。 如果每个页面单独打包自己的js，就可以在进入页面时候再加载自己的js，首屏加载就可以快很多12345optimization: &#123; splitChunks:&#123; chunks:&apos;all&apos; &#125;&#125; 4、文件压缩webpack4只要在生产模式下，代码就会自动压缩1mode: &apos;production&apos; 5、使用外部扩展(全局变量)可以直接在全局使用定义的$变量12345678910import Webpack from &apos;webpack&apos;externals: &#123; &apos;$&apos;: &apos;jquery&apos; //npm包 //需要require(&apos;$&apos;) &#125;//或者plugins: [new Webpack.ProvidePlugin(&#123; $: &apos;jquery&apos;, // npm jQuery: &apos;jQuery&apos; // 本地Js文件&#125;)] 6、指定环境,定义环境变量1234567891011import Webpack from 'webpack'&#123; plugins: [ new webpack.DefinePlugin(&#123; 'process.env': &#123; VUEP_BASE_URL: JSON.stringify('http://localhost:8080') &#125; &#125;), ]&#125; 7、CSS Tree Shaking1234567891011121314yarn add glob-all purify-css purifycss-webpack const PurifyCSS = require(&apos;purifycss-webpack&apos;)const glob = require(&apos;glob-all&apos;)plugins:[ // 清除无用 css new PurifyCSS(&#123; paths: glob.sync([ // 要做 CSS Tree Shaking 的路径文件 path.resolve(__dirname, &apos;./src/*.html&apos;), // 请注意，我们同样需要对 html 文件进行 tree shaking path.resolve(__dirname, &apos;./src/*.js&apos;) ]) &#125;)] 8、js Tree Shaking清除到代码中无用的js代码，只支持import方式引入，不支持commonjs的方式引入只要mode是production就会生效，develpoment的tree shaking是不生效的，因为webpack为了方便你的调试123optimization: &#123; usedExports:true, &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue通信]]></title>
    <url>%2Fblog%2F2019%2F06%2F12%2FVue%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[props和$emitprops父传子，$emit子传父123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 Vue.component('child',&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; &lt;/div&gt; `, props:['message'],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit('getChildData',val) &#125; &#125; &#125;)//┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child :message="message" v-on:getChildData="getChildData"&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:'张不怂' &#125; &#125;, methods:&#123; //执行子组件触发的事件 getChildData(val)&#123; console.log(val) &#125; &#125; &#125;)//┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ // 挂载 var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 中央事件总线new Bus新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859Vue.component('brother1',&#123; data()&#123; return &#123; mymessage:'hello brother1' &#125; &#125;, template:` &lt;div&gt; &lt;p&gt;this is brother1 compoent!&lt;/p&gt; &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; &lt;/div&gt; `, methods:&#123; passData(val)&#123; //触发全局事件globalEvent bus.$emit('globalEvent',val) &#125; &#125; &#125;) //┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ Vue.component('brother2',&#123; template:` &lt;div&gt; &lt;p&gt;this is brother2 compoent!&lt;/p&gt; &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, data()&#123; return &#123; mymessage:'hello brother2', brothermessage:'' &#125; &#125;, mounted()&#123; //绑定全局事件globalEvent bus.$on('globalEvent',(val)=&gt;&#123; this.brothermessage=val; &#125;) &#125; &#125;)//┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ //中央事件总线 var bus=new Vue(); var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt; &lt;/div&gt; ` &#125;) provide和inject父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。123456789101112131415161718192021222324252627282930313233Vue.component('child',&#123; inject:['parent_var'],//得到父组件传递过来的数据 data()&#123; return &#123; mymessage:this.parent_var &#125; &#125;, template:` &lt;div&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#125;)//┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ Vue.component('parent',&#123; template:` &lt;div&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, provide:&#123; /* 比如你可以把用户登录信息存储在App.vue中，可以把 provide:&#123;app:this&#125;注入，后续所有组件通过inject:['app'], 就可以直接通过app.userInfo拿到用户信息 */ parent_var:'随便什么都可以（可以是this,可以是data中的数据）' &#125;, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) $attrs和$listeners还是多层的场景，App.vue–&gt;A—&gt;B,如果App直接想给B传递数据该怎么办？Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件App直接传递数据给组件Bapp.vue引入A组件123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="app"&gt; &#123;&#123;app&#125;&#125; // ******关键点***** &lt;A :app="app" @test="doTest"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import A from "./components/A";export default &#123; name: "App", data() &#123; return &#123; app: "我是App的数据" &#125;; &#125;, components: &#123; A &#125;, methods: &#123; doTest() &#123; console.log(this.app) &#125; &#125;&#125; A.vue引入B组件123456789101112131415161718192021222324&lt;template&gt; &lt;div class="hello"&gt; &lt;h6&gt;这里是A组件&lt;/h6&gt; &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt; &lt;p&gt;$listeners: &#123;&#123;$listeners&#125;&#125;&lt;/p&gt; // ******关键点***** v-bind传递的都是$attrs,v-on传递的都是$listeners &lt;B v-bind="$attrs" v-on="$listeners"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import B from "./B";export default &#123; name: "A", props: &#123; msg: String &#125;, components: &#123; B &#125;, mounted() &#123; console.log(this.$listeners); &#125;&#125;;&lt;/script&gt; B组件1234567891011121314151617181920212223&lt;template&gt; &lt;div class="hello"&gt; &lt;h6&gt;这里是B组件&lt;/h6&gt; // ******关键点***** &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "B", props: &#123; msg: String &#125;, mounted() &#123; // ******关键点***** // 为啥这里直接能emitApp组件传递的test呢？ // 因为在A组件中有一个关键操作是 &lt;B v-bind="$attrs" v-on="$listeners"/&gt; this.$emit("test"); &#125;&#125;;&lt;/script&gt; $parent和$children分别是获得父组件和子组件的实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546Vue.component('child',&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$parent.message = this.mymessage;//通过如此调用可以改变父组件的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; &lt;/div&gt; &#125;) Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;button @click="changeChildValue"&gt;test&lt;/button &gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, methods:&#123; changeChildValue()&#123; this.$children[0].mymessage = 'hello'; &#125; &#125;, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) v-model父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值1234567891011121314151617181920212223242526272829303132333435363738394041Vue.component('child',&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$emit('input',this.mymessage); //通过如此调用可以改变父组件上v-model绑定的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; &lt;/div&gt; &#125;) Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;child v-model="message"&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) Vue.observable()vue2.6之前，创建一个响应对象，必须在一个Vue实例中配置。现在我们可以在Vue实例外部，通过使用Vue.observable(data)创建，如下12345678910111213141516import vue from vue;const state = Vue.observable (&#123; counter: 0,&#125;);export default &#123; render () &#123; return ( &lt;div&gt; &#123;state.counter&#125; &lt;button v-on:click=&#123;() =&gt; &#123;state.counter ++; &#125;&#125;&gt; Increment counter &lt;/ button&gt; &lt;/ div&gt; ); &#125;,&#125;; vuex具体参考文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue数据更新问题]]></title>
    <url>%2Fblog%2F2019%2F06%2F11%2FVue%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Vue 的数组更新问题 以下参考 Vue 文档 由于 JavaScript 的限制，Vue 不能检测以下数组的变动： 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 2.当你修改数组的长度时，例如：vm.items.length = newLength 题外话 实际上，我们在 Vue 的数组书使用 splice、push等方法，Vue 都已经做了一层封装，所以它们才能出发视图更新，如果有想更加深入了解，可以阅读源码。 Vue 强制刷新——$forceUpdate() 如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。 类似的代码如下：123456// 在控制变量改变的时候进行 强制渲染更新let childrenRefs = this.$refs.elTabs.$childrenthis.$nextTick(() =&gt; &#123; childrenRefs.forEach(child =&gt; child.$forceUpdate())&#125;) 深拷贝数据先用一个数据深拷贝数据，这里使用了 slice 方法，然后置空，最后在 $nextTick 中赋值深拷贝出来的数组值。12345var newArray = this.questionData.slice(0)this.questionData = []this.$nextTick(function () &#123; this.questionData = newArray;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[gulp配置react开发环境]]></title>
    <url>%2Fblog%2F2019%2F05%2F25%2Fgulp%E9%85%8D%E7%BD%AEreact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[gulp与webpackgulp是对文件的处理,是Task Runner,节省了手动编译,手动打包这一步,但是单纯使用gulp没法去解决js中引入module的问题,可能会遇到项目中明明引入了babel语法转换,为什么浏览器会提示require is not defined报错,这是因为babel只解析语法,并不会去管js的模块引入。而webpack解决了require的问题,根据不同的文件转换需求引入不同的loader,最后打包出符合相应规则的静态资源文件。 Browserify-让浏览器加载Node模块 官方文档开头介绍:require(&#39;modules&#39;) in the browser 目前NPM的包大多都是通过CMD的方式打包的，除了特定的可以使用CMD模块加载器加载的模块，大部分nodejs模块无法直接使用到浏览器环境中。Browserify是一个供浏览器环境使用的模块打包工具，像在node环境一样，也是通过require(‘modules’)来组织模块之间的引用和依赖，既可以引用npm中的模块，也可以引用自己写的模块，然后打包成js文件，再在页面中通过&lt;script&gt;标签加载。 Browserify.transform指定转换模块,在打包过程中自动执行,在这里需要结合babel进行语法转换 详细配置react语法解析主要用到babel的@babel/preset-react插件,此外还会使用到browserSync进行自动检测刷新,less预处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const gulp = require('gulp') //引入gulpconst less = require('gulp-less') //引入gulp-less处理less语法const LessAutoprefix = require('less-plugin-autoprefix') //css兼容前缀const autoprefix = new LessAutoprefix(&#123; browsers: ['last 2 versions']&#125;)const del = require('del') //删除文件模块,在每次gulp任务前执行const babel = require('gulp-babel') //babelconst browserSync = require('browser-sync').create() //自动刷新const reload = browserSync.reload //reload示例,用于浏览器刷新const browserify = require('browserify') //模块处理const source = require('vinyl-source-stream') //将browerify流转换成gulp文件流const babelify = require('babelify') //用于browserify的babel编译器//主任务function main(cb) &#123; (async () =&gt; &#123; await del.sync('dist') //less gulp.src('./src/index.less').pipe(less(&#123; plugins: [autoprefix] &#125;)).pipe(gulp.dest('./dist')) //js browserify(&#123; entries:['./src/index.js'] &#125;) .transform(babelify,&#123; presets: ['@babel/env','@babel/preset-react'], plugins: ["@babel/plugin-transform-runtime"] &#125;) .bundle() //打包 .pipe(source('index.js')).pipe(gulp.dest('./dist')) gulp.src('./src/index.html').pipe(gulp.dest('./dist')) cb() &#125;)()&#125;//开发环境function devServer(cb)&#123; browserSync.init(&#123; server: &#123; baseDir: './dist' &#125; &#125;) gulp.watch("./src/**", gulp.series(lessChange,jsChange,htmlChange)) cb()&#125;//检测html变化function htmlChange()&#123; return gulp.src('./src/index.html').pipe(gulp.dest('./dist')).pipe(reload(&#123;stream:true&#125;))&#125;//检测样式文件function lessChange() &#123; return gulp.src('./src/index.less').pipe(less(&#123; plugins: [autoprefix] &#125;)).pipe(gulp.dest('./dist')).pipe(reload(&#123;stream:true&#125;))&#125;//检测js文件function jsChange(cb)&#123; browserify(&#123; entries:['./src/index.js'] &#125;) .transform(babelify,&#123; presets: ['@babel/env','@babel/preset-react'], plugins: ["@babel/plugin-transform-runtime"] &#125;) .bundle() .pipe(source('index.js')).pipe(gulp.dest('./dist')).pipe(reload(&#123;stream:true&#125;)) cb()&#125;//default默认任务,用于package.json执行脚本gulp任务gulp.task('default', gulp.series(main,devServer))]]></content>
  </entry>
  <entry>
    <title><![CDATA[指数运算性能比较]]></title>
    <url>%2Fblog%2F2019%2F04%2F08%2F%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[自定义递归函数1234function calculateExponent(base,exponent)&#123; if(exponent == 1) return base return base * calculateExponent(base,--exponent)&#125; Math.pow()Math.pow() 函数返回基数（base）的指数（exponent）次幂，即 base^exponent。 ES7指数操作符在ES7中引入了指数运算符**12 ** 2 // 4 比较性能(测试环境 v8)比较使用console.time和console.timeEnd方法,得出运算耗时123456789101112131415161718//依次比较10次幂,100次幂,1000次幂,10000次幂循环100次耗时console.time()for(let i =0;i&lt;100;i++)&#123; calculateExponent(i,10)&#125;console.timeEnd()console.time()for(let i =0;i&lt;100;i++)&#123; Math.pow(i,10)&#125;console.timeEnd()console.time()for(let i =0;i&lt;100;i++)&#123; i ** 10&#125;console.timeEnd() 结果得出四次结果耗时1234[&apos;10&apos;, 0.2, 0.052, 0.052],[&apos;100&apos;, 0.503, 0.057, 0.089],[&apos;1000&apos;, 3.273, 0.090, 0.083],[&apos;10000&apos;, 28.346, 0.081, 0.120] 可以发现递归函数时间大大多于其他两个方法,那么剔除递归函数的结果再看: 根据图可以发现,两个方法在不同数量级耗费的时间有长有短,在1000数量级时候**运算符时间却少于Math.pow,来到10000数量级时**运算符时间大幅度长于Math.pow,我们可以根据实际情况选择使用**还是Math.pow]]></content>
  </entry>
  <entry>
    <title><![CDATA[实现小程序拖拽排序]]></title>
    <url>%2Fblog%2F2019%2F03%2F27%2F%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[实现效果这是最近我做的一个需求,由于产品项目模块众多,达近80个模块,所以有了这个模块管理排序的需求,得益于小程序自带的组件movable-view(基础库 1.2.0 开始支持),使得拖拽这一交互效果的实现变得优雅。在这里记录下写这个模块的一些心得 核心方法有三个核心方法,分别是bindchange事件(movable-view自带事件,类似于touchmove事件),touchend事件,touchstart事件核心代码:12345678910111213141516touchStart(index, fatherIndex) &#123; this.clientX = null this.clientY = null&#125;,touchMoving(index, fatherIndex, event) &#123; this.clientX = event.detail.x + (this.moveAreaWidth / 4 / 2) //this.moveAreaWidth每个modal this.clientY = event.detail.y + ITEM_HEIGHT / 4&#125;,touchEnd(index, fatherIndex) &#123; if (this.clientX &amp;&amp; this.clientY) &#123; const row = Math.floor(this.clientY / (ITEM_HEIGHT / 2)) const column = Math.floor(this.clientX / (this.moveAreaWidth / 4)) const newIndex = row * 4 + column index == newIndex ? this.hasChangedSort = false : (this.hasChangedSort = true,this.handleDragEnd(index, fatherIndex, newIndex)) &#125;&#125; 在这里,touchStart事件初始化每次拖拽后设定的clientX,clientX值touchmove事件中需要处理这样一件事,根据每个模块的高度以及宽度(需要通过小程序APIwx.createSelectorQuery计算得出)实时计算出落点所在的x,y坐标,最后touchend事件计算出x,y坐标所对应的行列数,根据行列数计算出当前模块所在对应数组中的索引序列(handleDragEnd方法),在data数据源数组中替换两个模块数据的索引下标 遇到的问题由于直接改变索引下标会造成瞬闪现象,就是拖拽完成后模块会先在原来位置闪现一下再回到拖拽后的位置,这是因为操作数据会直接改变视图,所以我们需要一个延时操作$nextTick,在这个延时方法中去操作新位置模块的x,y坐标,就可以解决这个问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java链表基本功能实现]]></title>
    <url>%2Fblog%2F2019%2F03%2F05%2FJava%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[链表链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 接口一个基本的Java链表主要有一下的功能: add首先,新建一个List类,以及一个Node类,通过List类来调用方法123456789101112131415161718192021public class List&#123; private Node root;//定义链表的根节点 private int count = 0;//定义当前列表节点个数&#125;public class Node&#123; private String data;//这是一个数据类型是 String 的链表 private Node next; //每个Node类需要一个指向当前Node的下一个Node,才行形成链关系 pulic Node(String data)&#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public String getData() &#123; return data; &#125;&#125; 定义完基本数据类,我们来实现add方法在List中定义add1234567891011public void add(String data)&#123; Node newNode = new Node(data); if(this.root == null)&#123; this.root = newNode; &#125; else&#123; this.root.addNode(newNode,this); //我们需要传入当前list对象,用于新增节点后跟新count &#125;&#125; public void addCount() &#123; this.count++;&#125; Node类中实现addNode,它接受一个Node类型参数12345678910111213141516171819public void addNode(Node newNode,List list)&#123; if(!this.equals(newNode))&#123; if(this.next == null)&#123; this.next = newNode; list.addCount(); &#125; else &#123; //如果当前下个节点不为空,则让next继续调用addNode方法 this.next.addNode(newNode,list); &#125; &#125;&#125;//为了做到不重复新增数据,我们需要在Node类中实现一个equals方法public boolean equals(Node node)&#123; if(this.data == node.data)&#123; return true; &#125; return false;&#125; getget方法接受一个int类型的序号,用于找到当前类型对应位置的节点数据,在List类中定义get1234public String get(int index) &#123; if (this.root == null) return null; return this.root.get(index, 0);&#125; Node类中定义getNode方法,它除了接受index参数外,还接受一个步进参数step,用于匹配index是否等于当前step1234public String get(int index, int step) &#123; if (index == step) return this.data; return this.next.get(index, ++step);&#125; setset方法用于重新设置链表对应位置节点的数据,1234public void set(int index, String data) &#123; if (this.root == null || index &lt; 0 || index &gt; this.count) return; this.root.setNode(index, data, 0);&#125; containscontains方法返回一个Boolean,判断当前列表是否存在对应的数据12345//Listpublic boolean contains(String data) &#123; if (this.root == null) return false; return this.root.containNode(data);&#125; 在Node类中定义containNode方法123456789//Nodepublic boolean containNode(String data) &#123; if (this.data.equals(data)) &#123; return true; &#125; else &#123; if (this.next == null) return false; return this.next.containNode(data); &#125;&#125; size返回当前链表节点个数1234//Listpublic int size() &#123; return this.count;&#125; isEmpty判断当前链表是否为空123public boolean isEmpty() &#123; return this.count == 0;&#125; remove删除节点数据123456789101112131415//Listpublic void remove(String data) &#123; if (this.root == null) return; if (this.root.equals(data)) &#123; //根节点特殊处理 this.root = this.root.getNext(); this.count--; &#125; else &#123; this.root.removeNode(this.root, data,this); &#125;&#125;//同add操作,还需要另外定义一个reduceCount方法供Node实例调用public void reduceCount() &#123; this.count--;&#125; Node类中定义removeNode12345678910//Nodepublic void removeNode(Node pre, String data, List list) &#123; if (this.data.equals(data)) &#123; pre.next = this.next; list.reduceCount(); &#125; else &#123; if(this.next != null) this.next.removeNode(this, data,list); &#125; &#125; toArray将当前链表输出为array数组对象12345678//List 新增一个私有属性arrayListprivate String[] arrayList;publice String[] toArray()&#123; this.arrayList = new String[this.count]; this.root.toArrayNode(arrayList,0); return this.arrayList;&#125; Node类中定义toArrayNode方法1234567//Nodepublic void toArrayNode(String [] array,int step)&#123; array[step] = this.data; if(this.next != null)&#123; this.next.toArrayNode(array,++step); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端组件化开发]]></title>
    <url>%2Fblog%2F2019%2F02%2F18%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[什么是组件化开发 前端组件化开发，就是将页面的某一部分独立出来，将这一部分的 数据层（M）、视图层（V）和 控制层（C）用黑盒的形式全部封装到一个容器内，暴露出一些开箱即用的函数和属性供外部组件调用。 怎么设计一个组件 单一一个组件的功能是单一的,应该只做一件事。一个功能如果可以拆分成多个功能点，那就可以将每个功能点封装成一个组件，当然也不是组件的颗粒度越小越好，只要将一个组件内的功能和逻辑控制在一个可控的范围内即可。 与业务逻辑解耦一个组件应该是纯粹,不参杂业务逻辑的,当涉及到业务时,如日期选择组件,产品要求日期小于当日的不可以选择,否则弹出提示框提示用户,这是我们就应该通过传入的配置参数,来进行判断,如果开启不能选择小于当前日期配置的话,当用户点击不符合要求的日期时,通过组件事件传递,将该事件告知父组件,由父组件进行业务逻辑的处理。 可配置在一开始设计组件的时候就应该结合业务需求考虑哪些功能应该做成可配置式的,如干警端src/components/noResultComponent(用于空数据时的展示),默认的文案是暂无数据,但是在有时候刚进入页面时,此时网络正在请求数据,页面此时用暂无数据就不太合适,这时候可以传正在加载来告知用户,此时正在请求数据过程中请等待。 属性值的检验1.传入属性是否合法2.属性是否必传 在wepy中进行类型检查:123456props = &#123; text: &#123; type: String, default: '正在加载' &#125; &#125; Vue中类型检查1234567props = &#123; someprop: &#123; type: String, default: 'someText', required: true &#125; &#125; React中进行类型检查12345678910import React from 'react'import PropTypes from 'prop-types'class MyComponent extends React.Component &#123; render() &#123; // ... do things with the props &#125;&#125;MyComponent.propTypes = &#123; someProps:PropTypes.string.isRequired&#125; 组件生命周期 初始化阶段,读取属性值,并进行处理 展示阶段,监听属性变化,进行相应逻辑处理 组件销毁阶段,及时移除组件中对整个系统产生副作用的操作,如addEventListener,setInterval等等。 在小程序中定义组件生命周期123456789101112131415161718Component(&#123; lifetimes: &#123; attached() &#123; // 在组件实例进入页面节点树时执行 &#125;, detached() &#123; // 在组件实例被从页面节点树移除时执行 &#125;, &#125;, // 以下是旧式的定义方式，可以保持对 &lt;2.2.3 版本基础库的兼容 attached() &#123; // 在组件实例进入页面节点树时执行 &#125;, detached() &#123; // 在组件实例被从页面节点树移除时执行 &#125;, // ...&#125;) 事件传递 在wepy中,wepy.component基类提供$broadcast、$emit、$invoke三个方法用于组件之间的通信和交互在Vue中,子组件通过this.$emit发送,父组件只需监听该发送的事件即可在’React’中,父组件可以使用 props 向子组件传值，而子组件向父组件传值，需要在父组件内定义函数并通过属性传递给子组件，在子组件内通过调用该属性对应的函数，传入参数，传递给父组件内的函数，并在父组件的该函数中做逻辑的处理。12345678910111213141516171819202122232425262728//子组件class ChildComponent extends React.Components &#123; render() &#123; return ( &lt;button onClick=&#123; () =&gt; &#123; this.props.clickHandler('This is a click') &#125; &#125;&gt;&lt;/button&gt; ) &#125;&#125;//父组件import ChildComponent from './child-component'class ParentComponent extends React.Components &#123; clickHandler(message) &#123; console.log(message) &#125; render() &#123; return ( &lt;child-component clickHandler=&#123; this.clickHandler.bind(this) &#125; /&gt; ) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJs实现基本拖拽]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FRxJs%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[HTML123456789&lt;div id="anchor"&gt; &lt;div class="video" id="video"&gt; &lt;video width="100%" height="100%" controls &gt; &lt;source src="http://download.blender.org/peach/bigbuckbunny_movies/big_buck_bunny_480p_stereo.ogg" type="video/ogg"&gt; Your browser does not support HTML5 video. &lt;/video&gt; &lt;/div&gt;&lt;/div&gt; CSS12345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; * &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; html, body &#123; margin: 0; padding: 0; height: 2000px; background-color: #eee; &#125; #anchor &#123; height: 360px; width: 100%; background-color: #F0F0F0; &#125; .video &#123; width: 640px; height: 360px; margin: 0 auto; background-color: black; &#125; .video.video-fixed &#123; position: fixed; top: 10px; left: 10px; width: 320px; height: 150px; cursor: all-scroll; &#125; .video.video-fixed .masker &#123; display: none; &#125; .video.video-fixed:hover .masker &#123; display: block; position: absolute; width: 100%; height: 180px; background-color: rgba(0, 0, 0, 0.8); z-index: 2; &#125; &lt;/style&gt; JS12345678910111213141516171819202122232425262728293031323334 import &#123;Observable&#125; from 'rxjs/Rx' const $video = document.querySelector('#video')const $anchor = document.querySelector('#anchor')const scroll = Observable.fromEvent(document, 'scroll'). //监听document事件 map(e =&gt; $anchor.getBoundingClientRect().bottom &lt; 0). //map将event事件映射为判断式布尔值 subscribe(bool =&gt; &#123; //如果当前元素不在视窗内,则改变样式 if(bool)&#123; $video.classList.add('video-fixed') &#125;else&#123; $video.classList.remove('video-fixed') $video.style.transform = '' &#125; &#125;)const mouseDown = Observable.fromEvent($video, 'mousedown') //observe事件const mouseMove = Observable.fromEvent(document, 'mousemove')const mouseUp = Observable.fromEvent(document, 'mouseup')const videoBoundingRect = $video.getBoundingClientRect() //获取viedo元素rect对象const validValue = (value,max,min)=&gt;&#123; //比较函数,防止拖拽出屏幕 return Math.min(Math.max(value,min),max)&#125;mouseDown.filter(e =&gt; $video.classList.contains('video-fixed')). //filter过滤 switchMap(e =&gt; mouseMove.takeUntil(mouseUp)). //将高阶Oberve转换为低阶 withLatestFrom(mouseDown, (move, down) =&gt; &#123; //结合上一个observable源的结果 return &#123; //move.clientX - down.offsetX =&gt;处理抖动 x: validValue(move.clientX - down.offsetX,window.innerWidth - videoBoundingRect.width/2,0), y: validValue(move.clientY - down.offsetY,window.innerHeight - videoBoundingRect.height/2,0), &#125; &#125;). subscribe(e =&gt; &#123; $video.style.transform = `translate3D($&#123;e.x&#125;PX,$&#123;e.y&#125;px,0)` &#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJs初探]]></title>
    <url>%2Fblog%2F2018%2F12%2F29%2FRxJs%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[RxJSRxJS 是使用 Observables 的响应式编程的库，它使编写异步或基于回调的代码更容易。 简单demo使用rx.js实现一个canvas画板html1&lt;canvas&gt;&lt;/canvas&gt; 12345678910111213141516171819202122232425import &#123;Observable&#125; from 'rxjs/Rx' //引入rx Observable对象const canvas = document.querySelector('canvas')const ctx = canvas.getContext('2d') //获取canvas画笔ctx.beginPath()function drawEvent([first, sec]) &#123; ctx.moveTo(first.x, first.y) ctx.lineTo(sec.x, sec.y) ctx.stroke() &#125;const moveEvent = Observable.fromEvent(canvas,'mousemove') .map(e =&gt;&#123;x:e.offsetX,y:e.offsetY&#125;) .bufferCount(2,1) //定义move流 const downEvent = Observable.fromEvent(canvas,'mousedown').map(()=&gt;'down') //将Observable 结果映射为'down' //这里我们可以将Observable想象成一个数组,将数组的map方法类似于这里的map方法 const upEvent = Observable.fromEvent(canvas,'mouseup').map(()=&gt;'up') //将Observable 结果映射为'up' const upAndDown = downEvent.merge(upEvent) //融合两个Observable upAndDown.switchMap(e=&gt;e==='down'?moveEvent:Observable.empty()).subscribe(drawEvent) //subscribe: 注册处理程序的订阅引用 //因为事件处理流可能是异步的,我们不必在等待事件执行成功后再继续下一步操作,而是订阅一个注册事件,事件执行后再通知给订阅者 总结这只是一个简单的demo,用于展示RxJS的基本思想,一个面向过程的基本思想。]]></content>
  </entry>
  <entry>
    <title><![CDATA[摘录]]></title>
    <url>%2Fblog%2F2018%2F12%2F15%2F%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[你在池塘里活得很好，泥鳅很丑但会说喜庆话，癞蛤蟆很马虎但很有趣，田螺是个温柔的自闭症，小鲫鱼是你们共同的女神。有一天你听说，江河湖海，哪个都要更大，更好。你跳了出去，遇见了美丽的海豚，雄壮的白鲸，婀娜多姿的热带鱼，的确都是好的。就是偶尔，觉得世界很空，生活很咸。——姬霄]]></content>
  </entry>
  <entry>
    <title><![CDATA[event-bus发布订阅实现]]></title>
    <url>%2Fblog%2F2018%2F12%2F12%2Fevent-bus%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一个简单的实现了事件注册,订阅,注销的eventEmeitter 12345678910111213141516171819202122232425262728293031323334353637383940class EventEmeitter&#123; constructor()&#123; this._events = new Map() &#125; emit(type,context,...args)&#123; const handler = this._events.get(type) if(typeof handler !== 'function')&#123; throw Error(`[$&#123;type&#125;] 未绑定事件`) &#125; if(args.length &gt;= 3)&#123; handler.apply(context,args) &#125;else&#123; handler.call(context,...args) &#125; &#125; addEventListener(type,fn)&#123; if(!this._events.get(type))&#123; this._events.set(type,fn) console.log(`[$&#123;type&#125;] 事件绑定`) &#125;else&#123; throw Error(`[$&#123;type&#125;] 事件已绑定`) &#125; &#125; removeEventListener(type)&#123; this._events.delete(type) console.log(`[$&#123;type&#125;] 事件移除`) &#125;&#125;const emitter = new EventEmeitter()emitter.addEventListener('christmas',s=&gt;&#123; console.log(`Merry $&#123;s&#125;`)&#125;)emitter.emit('christmas',this,'Christmas')emitter.removeEventListener('Christmas')---[christmas] 事件绑定Merry Christmas[Christmas] 事件移除]]></content>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2Fblog%2F2018%2F12%2F05%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 第一次解法:12345678910var twoSum = function(nums, target) &#123; for(let i=0;i&lt;nums.length;i++)&#123; var result = targer - nums[i] var resultIndex = nums.indexOf(result) if(resultIndex &gt; -1 &amp;&amp; resultIndex !== i)&#123; return [i,resultIndex] &#125; &#125;&#125;执行用时:196ms hashMap:1234567891011var twoSum = function(nums, target) &#123; var map = new Map() for(let i=0;i&lt;nums.length;i++)&#123; var result = target - nums[i] if(map.has(result))&#123; return [map.get(result),i] &#125; map.set(nums[i],i) &#125;&#125;执行用时:80ms]]></content>
  </entry>
  <entry>
    <title><![CDATA[几种移动端rem布局解决方案]]></title>
    <url>%2Fblog%2F2018%2F11%2F21%2F%E5%87%A0%E7%A7%8D%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[rem概念rem是一种css单位,通常用于解决移动端各个手机显示适配问题,保证UI设计在不同手机,不同设备之间显示效果的一致性。它是相对于html根元素的字体大小而定,比如设定根元素字体大小font-size:16px,那么1rem = 16px viewportviewport是专为手机浏览器设计的一个meta标签； 有些屏幕很小有智能手机，但分辩率却可以做得很大，比如某些手机的默认分辨率为：1920*1080，比许多电脑桌面的都还大，传统桌面网站直接放到手机上阅读时，界面就会显得非常小，阅读体验就很差，就样就需要一种将原始视图在手机上放大的机制，使用viewport标签可以解决这个问题，如123456&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;initial-scale：初始缩放比例maximum-scale：允许缩放的最大比例minimum-scale：允许缩放的最小比例user-scalable：是否允许手动缩放 阿里解决方案(1rem = 100px)把下面这段已压缩过的原生JS放到HTML的 head 标签中即可（注:不要手动设置viewport，该方案自动帮你设置）1&lt;script&gt;!function(e)&#123;function t(a)&#123;if(i[a])return i[a].exports;var n=i[a]=&#123;exports:&#123;&#125;,id:a,loaded:!1&#125;;return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports&#125;var i=&#123;&#125;;return t.m=e,t.c=i,t.p=&quot;&quot;,t(0)&#125;([function(e,t)&#123;&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,&#123;value:!0&#125;);var i=window;t[&quot;default&quot;]=i.flex=function(normal,e,t)&#123;var a=e||100,n=t||1,r=i.document,o=navigator.userAgent,d=o.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i),l=o.match(/U3\/((\d+|\.)&#123;5,&#125;)/i),c=l&amp;&amp;parseInt(l[1].split(&quot;.&quot;).join(&quot;&quot;),10)&gt;=80,p=navigator.appVersion.match(/(iphone|ipad|ipod)/gi),s=i.devicePixelRatio||1;p||d&amp;&amp;d[1]&gt;534||c||(s=1);var u=normal?1:1/s,m=r.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;);m||(m=r.createElement(&quot;meta&quot;),m.setAttribute(&quot;name&quot;,&quot;viewport&quot;),r.head.appendChild(m)),m.setAttribute(&quot;content&quot;,&quot;width=device-width,user-scalable=no,initial-scale=&quot;+u+&quot;,maximum-scale=&quot;+u+&quot;,minimum-scale=&quot;+u),r.documentElement.style.fontSize=normal?&quot;50px&quot;: a/2*s*n+&quot;px&quot;&#125;,e.exports=t[&quot;default&quot;]&#125;]); flex(false,100, 1);&lt;/script&gt; 网易解决方案(1rem = 100px)123456789101112131415161718192021222324252627282930313233var win=windowwin.resize = &#123;&#125;; var timer = null; var rem = 12; var doc = win.document; var docEl = doc.documentElement; /** * 刷新页面REM值 */ function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; width = width &gt; 768 ? 640 : width; rem = width / 7.5; docEl.style.fontSize = rem + 'px'; &#125; /** * 页面缩放或重载时刷新REM */ win.addEventListener('resize', function () &#123; clearTimeout(timer); timer = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; clearTimeout(timer); timer = setTimeout(refreshRem, 300); &#125; &#125;, false); refreshRem(); 美团解决方案(1rem = 100px)1234567891011121314151617(function () &#123; function o() &#123; document.documentElement.style.fontSize = (document.documentElement.clientWidth &amp;&amp; document.documentElement.clientWidth &lt; 768 ? document.documentElement.clientWidth : 768) / 7.5 + "px" &#125; var e = null; window.addEventListener("resize", function () &#123; clearTimeout(e), e = setTimeout(o, 300) &#125;, !1), o() //3秒后检查如果html fontSize为0，手动触发计算fontSize。 setTimeout(function () &#123; if (parseInt(document.defaultView.getComputedStyle(document.documentElement).fontSize) == 0) &#123; o(); &#125; &#125;, 3000);&#125;)(window) 纯css方案12345html &#123; width: 100%; max-width:768px; font-size:calc(100vw/7.5);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[gulp配置示例]]></title>
    <url>%2Fblog%2F2018%2F11%2F20%2Fgulp%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Gulp是什么Gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效 Gulp能做什么 开发环境下，想要能够按模块组织代码，监听实时变化 css/js预编译，postcss等方案，浏览器前缀自动补全等 条件输出不同的网页，比如app页面和mobile页面 线上环境下，我想要合并、压缩 html/css/javascritp/图片，减少网络请求，同时降低网络负担 等等… gulp配置示例以及注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/******************************************************* gulp 组件 及 gulp task******************************************************/const gulp = require('gulp'); //引入gulpconst source = require('vinyl-source-stream'); //加载vinyl文件流处理const browserify = require('browserify'); //加载预编译browserSyncconst browserSync = require('browser-sync'); //实时更新插件const buffer = require('vinyl-buffer');const babel = require('babelify'); //babel语法转化const reload = browserSync.reload;const sourcemaps = require('gulp-sourcemaps'); //生成sourcemap文件const del = require('del'); //引入删除模块const argv = require('yargs').argv; // 引入参数 根据参数的不同 执行相应的任务 s 生产环境 p 测试环境 d 开发环境const __ = require('gulp-load-plugins')(); //可以不用引入 直接使用已经在package.json里的插件//先预定好各个元素的路径const domSrc = &#123; //js 路径 jsSrc: 'app/js/**/*.js', //js 库路径 jsLibsSrc: 'app/js/libs/**/*.js', //jquery 文件 jquerySrc:'app/js/libs/jquery/*.js', //config js路径 configSrc: 'app/js/config/*.js', //index路径 indexHtmlSrc: 'app/index.html', //页面路径 htmlSrc: 'app/**/*.html', //css路径 cssSrc: ['app/assets/**/*.css', 'app/assets/scss/app.scss'], //监听css路径 watchCssSrc: 'app/assets/**/*.&#123;css,scss&#125;', //监听css路径 //fonts路径 排除css文件 fontSrc: ['app/assets/fonts/*', '!app/assets/fonts/*.css'], //image路径 imgSrc: 'app/assets/images/**/*', //res路径 resSrc: 'app/assets/res/**/*', //dist 下的 JS distJsSrc: 'dist/js', //dist 下的 html distHtmlSrc: 'dist/html', //dist 下的 tpl distTplSrc: 'dist/tpl', //dist 下的css distCssSrc: 'dist/css', //dist 下的 fonts distFontsSrc: 'dist/fonts'&#125;//js 库文件 组文件 筛选const libsfilter = __.filter(domSrc.jsLibsSrc, &#123;restore: true, passthrough: false&#125;);//js 业务 文件 筛选const servicefilter = __.filter([domSrc.jsSrc, '!' + domSrc.jsLibsSrc], &#123;restore: true, passthrough: false&#125;);//html index.html 筛选const indexHtmlfilter = __.filter(domSrc.indexHtmlSrc, &#123;restore: true, passthrough: false&#125;);//配置configgulp.task('js:config', ()=&gt; &#123; var configSource = 'app/js/config/dev.js'; if (argv.s) &#123; //测试环境 configSource = 'app/js/config/staging.js'; &#125; else if (argv.p) &#123; //生产环境 configSource = 'app/js/config/prod.js'; &#125; return gulp.src(configSource) .pipe(__.rename('config.js')) .pipe(gulp.dest('app/js/config'));&#125;);//ES6 to ES5gulp.task('js:es6-2-es5', ()=&gt; &#123; return browserify(&#123;entries: 'app/js/myApp.js'&#125;) .transform(babel) //&#123;presets: ["es2015"]&#125; .bundle() //.pipe(__.sourcemaps.init()) .pipe(source('myApp.js')) .pipe(__.if(argv.p, __.streamify(__.uglify()))) .pipe(__.rename(&#123;suffix: '.min'&#125;)) //.pipe(__.sourcemaps.write('./')) .pipe(gulp.dest('dist/js'));&#125;);//JS 拷贝 libs ,components 文件夹gulp.task('js:copy-libs', ()=&gt; &#123; return gulp.src([domSrc.jsLibsSrc,'!'+domSrc.jquerySrc]) //.pipe(__.sourcemaps.init()) .pipe(__.flatten()) //移除目录结构 .pipe(__.concat("applibs.js")) //合并 .pipe(__.uglify()) //压缩 .pipe(__.rename(&#123;suffix: '.min'&#125;)) //重命名 //.pipe(__.sourcemaps.write('./')) .pipe(gulp.dest('dist/js/libs'));&#125;);//解析HTMLgulp.task('html', ()=&gt; &#123; return gulp.src(domSrc.htmlSrc) .pipe(gulp.dest('dist/'))&#125;);//复制 fontsgulp.task('fonts', ()=&gt; &#123; return gulp.src(domSrc.fontSrc) .pipe(gulp.dest('dist/css'));&#125;);//复制 图片gulp.task('image', ()=&gt; &#123; return gulp.src(domSrc.imgSrc) .pipe(gulp.dest('dist/imgs'));&#125;);//复制 resgulp.task('res', ()=&gt; &#123; return gulp.src(domSrc.resSrc) .pipe(gulp.dest('dist/res'));&#125;);//解析并合并压缩cssgulp.task('css', ()=&gt; &#123; return gulp.src(domSrc.cssSrc) .pipe(__.if('*.scss', __.sass())) .pipe(__.concat('app.css')) .pipe( __.minifyCss()) .pipe(__.rename((path)=&gt; &#123; path.basename += '.min'; &#125;)) .pipe(gulp.dest('dist/css'));&#125;);//清除dist下的JS文件gulp.task('clean:js', ()=&gt; &#123; return del([domSrc.distJsSrc]);&#125;);//清除dist 下的html文件gulp.task('clean:html', ()=&gt; &#123; return del([domSrc.distHtmlSrc, domSrc.distTplSrc]);&#125;);//清除dist下的 css 文件gulp.task('clean:css', ()=&gt; &#123; return del([domSrc.distCssSrc]);&#125;);//清除dist 下的 fonts文件gulp.task('clean:fonts', ()=&gt; &#123; return del([domSrc.distFontsSrc])&#125;);//本地服务器gulp.task('server', ()=&gt; &#123; browserSync(&#123; // tunnel: true, open: false, port: 9996, server: &#123; baseDir: ['dist'], index: ['./html/index.html', 'index.html'] &#125; &#125;); //js gulp.watch([domSrc.jsSrc,"!"+domSrc.configSrc], gulp.series('js', reload)); //css gulp.watch(domSrc.watchCssSrc, gulp.series('css', reload)); //html gulp.watch(domSrc.htmlSrc, gulp.series('html', reload)); //image gulp.watch(domSrc.imgSrc, gulp.series('image', reload));&#125;);gulp.task('clean', gulp.parallel('clean:js', 'clean:html', 'clean:css', 'clean:fonts'));gulp.task('js', gulp.series('clean:js', 'js:config', 'js:es6-2-es5', 'js:copy-libs'));gulp.task('copy', gulp.parallel('html', 'fonts', 'image', 'res'));gulp.task('default', gulp.series('clean', 'copy', 'js', 'css', 'server'));gulp.task('build', gulp.series('clean', 'copy', 'js', 'css'));]]></content>
  </entry>
  <entry>
    <title><![CDATA[1px border边框实现]]></title>
    <url>%2Fblog%2F2018%2F11%2F16%2F1px%20border%E8%BE%B9%E6%A1%86%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[由于移动端手机像素密度的差异,1px宽度的边框在不同的DPI下展示会有差异,可以通过下面这个方法来解决1234567891011121314151617181920212223242526272829303132&lt;!--解决1px边框--&gt;&lt;!--@ SASS语法--&gt;@mixin border-1px($color)&#123; position: relative; &amp;:after&#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid $color; content: ''; &#125;&#125;&lt;!--然后设置 统一的类 缩放--&gt;@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) &#123; .border-1px&#123; &amp;:after&#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) &#123; .border-1px&#123; &amp;:after&#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[cron定时器写法]]></title>
    <url>%2Fblog%2F2018%2F11%2F14%2Fcron%E5%AE%9A%E6%97%B6%E5%99%A8%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[corn命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令,例如Jenkins定时任务等.123456789* * * * * *┬ ┬ ┬ ┬ ┬ ┬│ │ │ │ │ |│ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)│ │ │ │ └───── month (1 - 12)│ │ │ └────────── day of month (1 - 31)│ │ └─────────────── hour (0 - 23)│ └──────────────────── minute (0 - 59)└───────────────────────── second (0 - 59, optional) 在一个区域里填写多个数值的方法： 逗号（’,’）分开的值，例如：“1,3,4,7,8” 连词符（’-‘）指定值的范围，例如：“1-6”，意思等同于“1,2,3,4,5,6” 星号（’*’）代表任何可能的值。例如，在“小时域”里的星号等于是“每一个小时”，等等 示例12//每三小时准点执行一次cron: &apos;0 0 */3 * * *&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[async库parallel/parallelLimit介绍]]></title>
    <url>%2Fblog%2F2018%2F11%2F13%2Fasync%E5%BA%93parallel-parallelLimit%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[parallelasync.js是一个功能强大的node异步流程控制库,parallel是async中用来执行并行任务流程的一个方法,parallel(tasks,callbackopt)接收两个参数: Name Type Description tasks Array/Iterable/Object 一个用于遍历的数据类型 callback Function (可选)返回一个数组或者对象,参数(err,result) 123456789101112131415const parallel = require('async/parallel')const time = new Date().getTime()parallel([(callback)=&gt;&#123; setTimeout(()=&gt;&#123; callback(null,'one') &#125;,1200)&#125;,(callback)=&gt;&#123; setTimeout(()=&gt;&#123; callback(null,'two') &#125;,1000)&#125;],(err,results)=&gt;&#123; console.log('time cost:',new Date().getTime()-time) console.log(results)&#125;) 执行结果:12time cost: 1201[ &apos;one&apos;, &apos;two&apos; ] parallel会等到所有函数返回结果后再返回最终的结果数组,并且按照顺序返回,不会因为第二个函数setTimeout的时间比第一个短就先返回 parallelLimitparallelLimit基本功能和parallel是一样的,不过它新增一个参数,用来控制同时执行的函数数量 Name Type Description tasks Array/Iterable/Object 一个用于遍历的数据类型 limit number 异步操作的最大数量 callback Function (可选)返回一个数组或者对象,参数(err,result) 123456789101112131415const parallelLimit = require('async/parallelLimit')const time = new Date().getTime()parallelLimit([(callback)=&gt;&#123; setTimeout(()=&gt;&#123; callback(null,'one') &#125;,1200)&#125;,(callback)=&gt;&#123; setTimeout(()=&gt;&#123; callback(null,'two') &#125;,1000)&#125;],1,(err,results)=&gt;&#123; console.log('time cost:',new Date().getTime()-time) console.log(results)&#125;) 运行结果12time cost: 2205[&quot;one&quot;, &quot;two&quot;] 因为设置的limit是1,所以运行时间是所有运行时间之和]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用for,set,map实现数组去重]]></title>
    <url>%2Fblog%2F2018%2F11%2F13%2F%E4%BD%BF%E7%94%A8for-set-map%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重的场景在开发中还是经常遇见的,比如一个地图选房功能,在地图上标识一个区域,显示区域上的房型,移动区域后显示新增的房型以及原来还在区域内的房型保持不变,实现这一个场景,就需要得出每次不变的房型的数组,以及新增的房型的数组.一般的,后台返回的数据只是我们选中的区域的房型数据,我们要对数据进行加工处理. 构造数据让我们先来生成模拟数据,并打乱我们生成的数据,模拟真实情况123456789101112131415161718192021222324252627282930313233343536373839function generateHouses(n) &#123; //生成数据 let newHouse = new Array(n) let oldHouse = new Array(n) for (let i = 0; i &lt; n / 2; i++) &#123; newHouse[i] = oldHouse[i] = &#123; id: i &#125; &#125; for (let i = n / 2; i &lt; n; i++) &#123; newHouse[i] = &#123; id: n * 2 + i &#125; oldHouse[i] = &#123; id: n + i &#125; &#125; return &#123; newHouse: randomArr(newHouse), oldHouse: randomArr(oldHouse) &#125;&#125;function randomArr(arr) &#123; //数组洗牌 for (var i = arr.length - 1; i &gt;= 0; i--) &#123; var randomIndex = Math.floor(Math.random() * (i + 1)); var itemAtIndex = arr[randomIndex]; arr[randomIndex] = arr[i]; arr[i] = itemAtIndex; &#125; return arr&#125;const &#123;newHouse,oldHouse&#125; = generateHouses(n) //n为需要构造的数据量const newSetHouse = new Set(newHouse) //构造set数据const newMapHouse = new Map() //构造map数据 for(let index in newHouse)&#123; newMapHouse.set(newHouse[index].id,newHouse[index]) &#125; For循环for循环方法进行两次循环,因为每判断一次新数据就需要遍历一遍老数据,所以时间复杂度为O(N^2),对于1000的数据,最坏的情况要判断1000000次123456789101112131415161718192021222324252627function filterHouse_for(newHouse, oldHouse) &#123; if (newHouse.length === 0) &#123; return &#123; remainHouse: oldHouse, newHouse: newHouse &#125; &#125; let remainHouse = [] let newOutPutouse = [] for (let nIndex in newHouse) &#123; let isNew = true for (let oIndex in oldHouse) &#123; if (newHouse[nIndex].id === oldHouse[oIndex].id) &#123; remainHouse.push(newHouse[nIndex]) isNew = false break &#125; &#125; if (isNew) &#123; newOutPutouse.push(newHouse[nIndex]) &#125; &#125; return &#123; remainHouse, newOutPutouse &#125;&#125; Set方法set是ES6新增的一种数据类型,它的成员是唯一的,所以用来进行去重是非常合适的,总体时间复杂度相较于for循环,它变成了O(NlogN),所以与for循环的时间长短比较取决于系数N,当系数较小时,差别不是很大,但当系数变大时,for循环消耗的时间是成指数级别增加的123456789101112131415function filterHouse_set(newHouse, oldHouse,newSetHouse) &#123; let remainHouse = [] let newOutPutouse = [] for (let index in oldHouse) &#123; if (newSetHouse.has(oldHouse[index])) &#123; remainHouse.push(oldHouse[index]) &#125; else &#123; newOutPutouse.push(oldHouse[index]) &#125; &#125; return &#123; remainHouse, newOutPutouse &#125;&#125; Map方法哈希的时间复杂度为O(1)，因此总的时间复杂度为O(N)，代价是哈希的存储空间通常为数据大小的两倍,并且需要手动先构造map数据1234567891011function filterHouse_map(newHouse,oldHouse,newMapHouse)&#123; let remainHouse = [] let newOutPutouse = [] oldHouse.map(ele=&gt;&#123; newMapHouse.has(ele.id)?remainHouse.push(ele):newOutPutouse.push(ele) &#125;) return &#123; remainHouse, newOutPutouse &#125;&#125; 时间比较写一个函数来比较三种方法需要的时间12345678910111213141516171819202122232425262728function test(n)&#123; const &#123; newHouse, oldHouse &#125; = generateHouses(n) /* for */ console.log('for Start') var time = new Date().getTime() filterHouse_for(newHouse, oldHouse) console.log('for End', new Date().getTime() - time) /* set */ const newSetHouse = new Set(newHouse) //构造set数据 console.log('set Start') var time = new Date().getTime() filterHouse_set(newHouse, oldHouse,newSetHouse) console.log('set End', new Date().getTime() - time) /* map */ const newMapHouse = new Map() //构造map数据 for(let index in newHouse)&#123; newMapHouse.set(newHouse[index].id,newHouse[index]) &#125; console.log('map Start') var time = new Date().getTime() filterHouse_map(newHouse, oldHouse,newMapHouse) console.log('map End', new Date().getTime() - time)&#125; 运行结果(chrome下运行(版本 70))当 n 为10时:1234567test(100)VM253:97 for StartVM253:100 for End 3VM253:104 set StartVM253:107 set End 0VM253:114 map StartVM253:117 map End 0 当 n 为1000时:123456for StartVM253:100 for End 60VM253:104 set StartVM253:107 set End 1VM253:114 map StartVM253:117 map End 0 当 n 为10000时:123456for StartVM253:100 for End 4532VM253:104 set StartVM253:107 set End 5VM253:114 map StartVM253:117 map End 2 当 n 为100000时:因为for循环等了几分钟都没有算出结果,就不比较for循环了1234set StartVM231:102 set End 37VM231:109 map StartVM231:112 map End 30 当 n 为10000000时:123456test(1000000)VM231:99 set StartVM231:102 set End 466VM231:109 map StartVM231:112 map End 592 结论可以看出,不论哪种情况,for循环用时都是最长的,所以不要使用for循环😋,数据量是十万级别以下时,使用map速度比set快一些,十万级别以上时使用set]]></content>
  </entry>
  <entry>
    <title><![CDATA[Fisher–Yates shuffle 洗牌算法]]></title>
    <url>%2Fblog%2F2018%2F11%2F12%2FFisher%E2%80%93Yates%20shuffle%20%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。 Fisher and Yates 的原始版 Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher 和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下： 写下从 1 到 N 的数字取一个从 1 到剩下的数字（包括这个数字）的随机数 k从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位重复第 2 步，直到所有的数字都被取出第 3 步写出的这个序列，现在就是原始数字的随机排列已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。 JavaScript 代码实现 12345678910111213141516/** * Fisher–Yates shuffle */Array.prototype.shuffle = function() &#123; var input = this; for (var i = input.length-1; i &gt;=0; i--) &#123; var randomIndex = Math.floor(Math.random()*(i+1)); var itemAtIndex = input[randomIndex]; input[randomIndex] = input[i]; input[i] = itemAtIndex; &#125; return input;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[在npm/yarn中配置.npmrc/.yarnrc文件,设置镜像和代理]]></title>
    <url>%2Fblog%2F2018%2F11%2F12%2F%E5%9C%A8npm-yarn%E4%B8%AD%E9%85%8D%E7%BD%AE-npmrc-yarnrc%E6%96%87%E4%BB%B6-%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[12345//指定淘宝源registry=https://registry.npm.taobao.org//指定代理proxy=http://localhost:1080https-proxy=https://localhost:1080]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用async库结合puppeteer并发爬取网易云音乐歌单(简易demo)]]></title>
    <url>%2Fblog%2F2018%2F11%2F09%2F%E4%BD%BF%E7%94%A8async%E5%BA%93%E5%B9%B6%E5%8F%91%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%AD%8C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[async是node的一个强大的异步第三方库,它包含许多功能方法,今天主要用其中的mapLimit方法来实现并行执行爬虫.mapLimit(coll,limit, iteratee, callbackopt)接收四个参数:coll:是一个迭代器,代表要迭代的集合limit:数字代表同时执行并行的限制iteratee:迭代器方法,对于coll中的每一个item，迭代执行该异步函数。用(item, callback)调用，callback可选callbackopt:所有iteratee 函数完成后或发生错误时触发的回调函数。用(err, results)调用。1234567891011121314151617181920212223242526272829303132333435const puppeteer = require(&apos;puppeteer&apos;)const cheerio = require(&apos;cheerio&apos;)const mapLimit = require(&apos;async/mapLimit&apos;)const URL = &apos;https://music.163.com&apos;//标签集合const type =[&apos;华语&apos;,&apos;欧美&apos;,&apos;日语&apos;,&apos;韩语&apos;,&apos;粤语&apos;,&apos;小语种&apos;]async function start(type,callback)&#123; const browser = await puppeteer.launch(&#123; headless:true &#125;) const page = await browser.newPage() await page.goto(`$&#123;URL&#125;/discover/playlist/?cat=$&#123;type&#125;`) const $ = cheerio.load(await page.mainFrame().childFrames()[0].content()) const list = $(&apos;#m-pl-container&apos;).find(&apos;li&apos;) let album = [] Array.from(list).forEach(ele=&gt;&#123; let obj =&#123; name:$(ele).find(&apos;.dec a&apos;).attr(&apos;title&apos;), href:$(ele).find(&apos;.dec a&apos;).attr(&apos;href&apos;) &#125; album.push(obj) &#125;) callback(null,album) await browser.close()&#125;mapLimit(type,5,(type,callback)=&gt;&#123;//设置并发数为 5 start(type,callback)&#125;,(err,result)=&gt;&#123; for(let index in result)&#123; console.log(result[index]) &#125;&#125;) result:]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Puppeteer爬虫]]></title>
    <url>%2Fblog%2F2018%2F11%2F08%2F%E4%BD%BF%E7%94%A8Puppeteer%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Puppeteer是 GoogleChrome团队官方的无界面（Headless）Chrome工具，它是一个Node库，提供了一个高级的API来控制DevTool协议上的无头版 Chrome 。也可以配置为使用完整（非无头）的 Chrome。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const puppeteer = require('puppeteer')const cheerio = require('cheerio')const fs = require('fs')const assert = require('assert')async function start() &#123; const browser = await puppeteer.launch() const page = await browser.newPage() //过滤请求资源// await page.setRequestInterception(true)// page.on('request', interceptedRequest =&gt; &#123;// if (interceptedRequest.url().endsWith('.png') ||// interceptedRequest.url().endsWith('.jpg') ||// interceptedRequest.url().endsWith('.gif'))// interceptedRequest.abort()// else// interceptedRequest.continue()// &#125;) await page.goto('http://jandan.net/ooxx') const $ = cheerio.load(await page.content()) const $img = $('img') for (let index in $img) &#123; try &#123; const content = await getResourceContent(page, ($img[index].attribs.src)) const contentBuffer = Buffer.from(content, 'base64') const fileName = $img[index].attribs.src.match( /^http(s)?:\/\/(.+)\/(.+)\/(.+\..+)/)[4] fs.writeFileSync(fileName, contentBuffer, 'base64') &#125; catch (e) &#123;&#125; &#125; await browser.close()&#125;//获得资源树async function getResourceTree(page) &#123; var resource = await page._client.send('Page.getResourceTree') return resource.frameTree&#125;//根据url frameId查找资源实例async function getResourceContent(page, url) &#123; const &#123;content, base64Encoded&#125; = await page._client.send( 'Page.getResourceContent', &#123;frameId: String(page.mainFrame()._id), url&#125;, ) assert.strictEqual(base64Encoded, true) return content&#125;start()]]></content>
  </entry>
</search>
