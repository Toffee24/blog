<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue transition实现原生页面跳转效果]]></title>
    <url>%2Fblog%2F2019%2F08%2F21%2Ftransition%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%94%9F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[代码使用Vue &lt;transition&gt; 组件过渡 123&lt;transition :name=&quot;this.$store.routeAction&quot;&gt; &lt;router-view/&gt;&lt;/transition&gt; CSS1234567891011121314151617181920212223242526.push-enter-active,.push-leave-active, .pop-enter-active,.pop-leave-active&#123; transition: all 0.4s;&#125;.push-leave-to&#123;transform: translate(-20%,0);&#125;.push-enter &#123; transform: translate(100%, 0);&#125;.push-enter-active &#123; z-index: 10;&#125;.push-leave-active &#123; z-index: 0;&#125;.pop-leave-active &#123; transform: translate(100%, 0); z-index: 11;&#125;.pop-enter&#123; transform: translate(-20%,0);&#125; 效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[chrome快捷键太反人类?不想安装额外插件?那就用TamperMonkey写个脚本]]></title>
    <url>%2Fblog%2F2019%2F07%2F19%2Fchrome%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%AA%E5%8F%8D%E4%BA%BA%E7%B1%BB-%E4%B8%8D%E6%83%B3%E5%AE%89%E8%A3%85%E9%A2%9D%E5%A4%96%E6%8F%92%E4%BB%B6-%E9%82%A3%E5%B0%B1%E7%94%A8TamperMonkey%E5%86%99%E4%B8%AA%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Chrome快捷键对于一天用到将近百余次的ctrl+w的我来说,一直觉得chrome原本的ctrl+w的按键有点别扭,终于在今天忍不住了,开始寻找如何去修改chrome默认的快捷键。在设置里找了一圈,发现没有,无奈google了一下,发现有这么几种办法 安装chrome插件 如Shortkeys等 修改chrome系统文件我综合了一下,发现我只需要实现alt + w关闭浏览器TAB的功能,这么折腾似乎不太经济,突然想到我有安装TamperMonkey油猴插件,于是便想到自己动手写个js脚本完事 TamperMonkeyTamperMonkey是一个浏览器插件,它是一个脚本管理器,通过脚本市场安装第三方js脚本,可以实现非常多的拓展功能,可以就不展开了我们新建一个脚本文件,注意脚本文件开头 match选项表示脚本应用的范围,这里我们应用所有网站12// @match http://*/*// @match https://*/* 编写脚本好了,下面就开始编写我们的脚本,TamperMonkey脚本文件实质就是输出个js IFFE(立即执行函数),脚本内容都编写在里面,我们只需要全局监听onkeydown事件,判断是否同时按下alt + w,然后执行window.close()关闭页面就可以了12345678(function() &#123; window.addEventListener('keydown',function(event)&#123; if (event.altKey &amp;&amp; event.keyCode == 87) &#123; window.location.href = "about:blank" window.close() &#125; &#125;)&#125;)()]]></content>
  </entry>
  <entry>
    <title><![CDATA[收集常用的css代码]]></title>
    <url>%2Fblog%2F2019%2F07%2F11%2F%E6%94%B6%E9%9B%86%E5%B8%B8%E7%94%A8%E7%9A%84css%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[清除默认样式reset 12345678910111213141516171819202122html,body&#123;height:100%;&#125;html,body,h1,h2,h3,h4,h5,h6,div,dl,dt,dd,ul,ol,li,p,blockquote,pre,hr,figure,table,caption,th,td,form,fieldset,legend,input,button,textarea,menu&#123;margin:0;padding:0;&#125;header,footer,section,article,aside,nav,hgroup,address,figure,figcaption,menu,details&#123;display:block;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125;caption,th&#123;text-align:left;font-weight:normal;&#125;html,body,fieldset,img,iframe,abbr&#123;border:0;&#125;i,cite,em,var,address,dfn&#123;font-style:normal;&#125;[hidefocus],summary&#123;outline:0;&#125;li&#123;list-style:none;&#125;h1,h2,h3,h4,h5,h6,small&#123;font-size:100%;&#125;sup,sub&#123;font-size:83%;&#125;pre,code,kbd,samp&#123;font-family:inherit;&#125;q:before,q:after&#123;content:none;&#125;textarea&#123;overflow:auto;resize:none;&#125;label,summary&#123;cursor:default;&#125;a,button&#123;cursor:pointer;&#125;h1,h2,h3,h4,h5,h6,em,strong,b&#123;font-weight:bold;&#125;del,ins,u,s,a,a:hover&#123;text-decoration:none;&#125;body,textarea,input,button,select,keygen,legend&#123;font:12px/1.14 Microsoft YaHei,arial,\5b8b\4f53;color:#333;outline:0;&#125;body&#123;background:#fff;&#125;a,a:hover&#123;color:#333;&#125;*&#123;box-sizing: border-box;&#125; 去除input默认填充的背景颜色 123input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px white inset;&#125; 清除input[type=number]的默认样式 12345678input[type=number] &#123; -moz-appearance:textfield;&#125;input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button &#123; -webkit-appearance: none; margin: 0;&#125; 清除移动端 a 标签等点击区域变色 123*&#123; -webkit-tap-highlight-color: rgba(255, 255, 255, 0);&#125; 清除移动端 input 样式 12345678input&#123; border: none; -moz-appearance:none; -webkit-appearance : none ; /*解决ios上按钮的圆角问题*/ border-radius: 0; /*解决ios上输入框圆角问题*/ outline:medium; /*去掉鼠标点击的默认黄色边框*/ background-color: transparent;&#125; 避免ios滑动滚动条卡顿 123*&#123; -webkit-overflow-scrolling : touch&#125; 滚动条样式 123456789101112131415161718192021222324252627282930.scroll-container &#123; height: 250px; border: 1px solid #ddd; padding: 15px; overflow: auto; .row &#123; margin: 0; line-height: 1.5; &#125; &amp;::-webkit-scrollbar &#123; width: 8px; background: white; &#125; &amp;::-webkit-scrollbar-corner, /* 滚动条角落 */ &amp;::-webkit-scrollbar-thumb, &amp;::-webkit-scrollbar-track &#123; border-radius: 4px; &#125; &amp;::-webkit-scrollbar-corner, &amp;::-webkit-scrollbar-track &#123; /* 滚动条轨道 */ background-color: rgba(180, 160, 120, 0.1); box-shadow: inset 0 0 1px rgba(180, 160, 120, 0.5); &#125; &amp;::-webkit-scrollbar-thumb &#123; /* 滚动条手柄 */ background-color: #00adb5; &#125;&#125; 常用 midea媒体查询 12345678910111213141516171819202122232425262728293031323334353637/* 横屏 */@media screen and (orientation:landscape)&#123; &#125;/* 竖屏 */@media screen and (orientation:portrait)&#123; &#125;/* 窗口宽度&lt;960,设计宽度=768 */@media screen and (max-width:959px)&#123; &#125;/* 窗口宽度&lt;768,设计宽度=640 */@media screen and (max-width:767px)&#123; &#125;/* 窗口宽度&lt;640,设计宽度=480 */@media screen and (max-width:639px)&#123; &#125;/* 窗口宽度&lt;480,设计宽度=320 */@media screen and (max-width:479px)&#123; &#125;/* 设备像素比为2 *//* 常用于1px边框，还应规定 3dppx 的情况 */@media (min-resolution: 2dppx) &#123;&#125;/* windows UI 贴靠 */@media screen and (-ms-view-state:snapped)&#123; &#125;/* 打印 */@media print&#123; &#125; 长文本折行 1234.long-text&#123; white-space: pre-line; word-wrap: break-word;&#125; 文字超出显示省略号单行文字1234567/*注意宽度是必须的*/.article-container &#123; width: 500px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 多行文字 12345678.article-container &#123; display: -webkit-box; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 4; //需要显示的行数 overflow: hidden; text-overflow: ellipsis;&#125; 消除图片下方间隙 通过设置给 img 元素设置 vertical-align: top 消除行内元素的间隙（仅对 img 元素有用 1vertical-align: top; 图文居中 1234&lt;div class="container"&gt; &lt;img src="../../public/images/bg1.jpg"&gt; &lt;span&gt;安能摧眉折腰事权贵，使我不得开心颜&lt;/span&gt;&lt;/div&gt; 123456.container&#123; padding:15px 0; img&#123; vertical-align: middle; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用webpack4配置一个完整的react前端工程]]></title>
    <url>%2Fblog%2F2019%2F06%2F13%2F%E4%BD%BF%E7%94%A8webpack4%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、基础配置1、init1234mkdir webpack-projectcd webpack-projectmkdir srcyarn init 2、安装1234567891011121314yarn add webpack webpack-cli webpack-dev-servertouch webpack.config.js// webpack.config.jsmodule.exports = &#123; mode: "development", entry: ["./src/index.js"], output: &#123; path: path.join(__dirname,'dist'), filename: "bundle.js" &#125;, module: &#123;&#125;, plugins: &#123;&#125;, devServer: &#123;&#125;&#125; 3、安装react123456789yarn add react react-dom react-router-dom// 建立如下的文件目录，并编写安装react和react-router并编写react代码如下|-src│ index.js 主文件├───pages│ Count.jsx -- 实现了一个计数器的功能，点击按钮，会让数字增加，按钮会实时显示在页面上│ Home.jsx -- 一个简单的文字展示└───router index.js -- 路由配置文件，两个页面分别对应两个路由 count和 home 4、babel编译es6,jsx等12345678910111213// @babel/core-babel核心模块 @babel/preset-env-编译ES6等 @babel/preset-react-转换JSXyarn add babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/preset-react// @babel/plugin-transform-runtime: 避免 polyfill 污染全局变量，减小打包体积// @babel/polyfill: ES6 内置方法和函数转化垫片yarn add @babel/polyfill @babel/runtime//module配置&#123; test: /\.jsx?$/, exclude: &apos;/node_modules/&apos;, use: [&#123; loader: &apos;babel-loader&apos; &#125;]&#125; 根目录新建.babelrc文件1234&#123; "presets": ["@babel/preset-env","@babel/preset-react"], "plugins": ["@babel/plugin-transform-runtime"]&#125; 5、按需引入babel-polyfill一般地,安装完@babel/polyfill之后,在入口文件直接import,但这样会有导致引入不需要的语法垫片,导致打包出来的文件过大的问题当配合@babel/preset-env一起使用时,更改.babelrcuseBuiltIns表示只打包项目使用到的123456&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;usage&quot; &#125;, //entry 表示完整引入 &quot;@babel/preset-react&quot;], &quot;plugins&quot;: [&quot;@babel/plugin-transform-runtime&quot;]&#125; 如果没有用到@babel/preset-env时,可以在entry入口导入,但是官方建议还是不要这么做123module.exports = &#123; entry:['@babel/polyfill','./src/index.js']&#125; 6、插件CleanWebpackPlugin每次打包都会在dist生成新的文件,所以需要这个插件在每次打包前删除上次打包好的文件12345yarn add CleanWebpackPluginimport CleanWebpackPlugin from 'clean-webpack-plugin'plugins :[ new CleanWebpackPlugin() ] 7、使用HtmlWebpackPlugin现在我们生成的都是js文件,但是我们还需要html,使用这个插件可以通过设置的模板html生成自动关联js路径的最终的html123456789101112yarn add html-webpack-plugincd srctouch index.html//webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin');plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; filename: 'index.html', // 最终创建的文件名 template: path.join(__dirname, 'src/template.html') // 指定模板路径 &#125;) ] 8、使用dev-tool配置项进行source-map优化webpack中devtool选项用来控制是否生成，以及如何生成 source map。简言之，source map就是帮助我们定位到错误信息位置的文件。正确的配置source map，能够提高开发效率，更快的定位到错误位置。12345//webpack.config.jsmodule.exports = &#123; devtool:'cheap-module-eval-source-map',//线上环境 devtool:'cheap-module-source-map'//测试环境&#125; 9、使用WebpackDevServer配置开发服务器webpack-dev-server是在本地开发部署的一个小型的静态资源服务器,提供实时重载功能123456789101112131415//webpack.config.jsmodule.exports = &#123; devServer: &#123; hot:true, inline:true, contentBase:path.join(__dirname,'dist'), host:'0.0.0.0',//方便局域网访问 port:8080, historyApiFallback: true, // 该选项的作用所有的404都连接到index.html proxy: &#123; // 代理到后端的服务地址，会拦截所有以api开头的请求地址, 解决跨域问题 "/api": "http://xxx.xxx.x.xx:xxxx" &#125; &#125;&#125; 10、使用HotModuleReplacement热更新(HMR)建立了开发环境本地服务器后，当修改内容后，网页会同步刷新，我们现在进入toCount页面 点击按钮，将数字加到一个不为0的数，比如加到6 然后你可以在代码中改变按钮的文字，随便改点东西，会发现，页面刷新后，数字重新变为0这显然不是我们想要的，想要的是，能不能把页面的状态保存了，也就是更改了代码后，页面还是保存了数字为6的状态,也就是局部改变。这时就要用到HotModuleReplacement这个插件12345678910111213141516//webpack.config.jsmodule.exports = &#123; devServer: &#123; hot:true, inline:true, contentBase:path.join(__dirname,'dist'), host:'0.0.0.0',//方便局域网访问 port:8080, historyApiFallback: true, // 该选项的作用所有的404都连接到index.html proxy: &#123; // 代理到后端的服务地址，会拦截所有以api开头的请求地址, 解决跨域问题 "/api": "http://xxx.xxx.x.xx:xxxx" &#125; &#125;, plugins:[new webpack.HotModuleReplacementPlugin()]&#125; 11、react-hot-loader记录react页面留存状态statereact-hot-loader是解决在react开发中的页面留存状态刷新问题1234567891011121314151617181920212223242526272829303132cnpm i react-hot-loader -D // 在主文件里这样写 import React from "react";import ReactDOM from "react-dom";import &#123; AppContainer &#125; from "react-hot-loader";-------------------1、首先引入AppContainreimport &#123; BrowserRouter &#125; from "react-router-dom";import Router from "./router"; /*初始化*/renderWithHotReload(Router);-------------------2、初始化 /*热更新*/if (module.hot) &#123;-------------------3、热更新操作 module.hot.accept("./router/index.js", () =&gt; &#123; const Router = require("./router/index.js").default; renderWithHotReload(Router); &#125;);&#125; function renderWithHotReload(Router) &#123;-------------------4、定义渲染函数 ReactDOM.render( &lt;AppContainer&gt; &lt;BrowserRouter&gt; &lt;Router /&gt; &lt;/BrowserRouter&gt; &lt;/AppContainer&gt;, document.getElementById("app") );&#125; 12、编译css和scss/less12345678910yarn add css-loader style-loader sass-loader node-sass / less-loader //webpack.config.js&#123; test: /\.scss$/, use: [ &quot;style-loader&quot;, // 创建style标签，并将css添加进去 &quot;css-loader&quot;, // 编译css &quot;sass-loader&quot; // 编译scss ]&#125; 13、使用PostCSSPostCSS是一个使用JS插件转换css样式的工具,最常用到的就是Autoprefixer这个插件,但还有许多的插件比如postcss-preset-env,可以使用实验性的css特性,stylelintcss语法检测等1234567891011yarn add postcss-loader//webpack.config.js&#123; test: /\.scss$/, use: [ "style-loader", // 创建style标签，并将css添加进去 "css-loader", // 编译css "postcss-loader", "sass-loader" // 编译scss ]&#125; 14、处理图片123456789101112131415yarn add file-loader url-loader url-loader 解决css等文件中引入图片路径的问题file-loader 当图片较小的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝//webpack.config.js&#123; test: /\.(png|jpg|jpeg|gif|svg)/, use: &#123; loader: 'url-loader', options: &#123; outputPath: 'images/', // 图片输出的路径 limit: 10 * 1024 &#125; &#125;&#125; 15、处理字体1234567891011121314&#123; test: /\.(eot|woff2?|ttf|svg)$/, use: [ &#123; loader: 'url-loader', options: &#123; name: '[name]-[hash:5].min.[ext]', limit: 5000, // fonts file size &lt;= 5KB, use 'base64'; else, output svg file publicPath: 'fonts/', outputPath: 'fonts/' &#125; &#125; ] &#125; webpack优化1、extension,alias对文件路径后缀名优化 extension: 指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配 alias: 配置别名可以加快webpack查找模块的速度12345678resolve: &#123; extension: ["", ".js", ".jsx"], alias: &#123; "@": path.join(__dirname, "src"), pages: path.join(__dirname, "src/pages"), router: path.join(__dirname, "src/router") &#125; &#125; 2、MiniCssExtractPlugin抽取css文件如果不做配置，我们的css是直接打包进js里面的，我们希望能单独生成css文件。 因为单独生成css,css可以和js并行下载，提高页面加载效率12345678910111213141516171819202122yarn add mini-css-extract-plugin//webpack.config.jsconst MiniCssExtractPlugin = require("mini-css-extract-plugin"); &#123; &#123; test: /\.scss$/, use: [ // "style-loader", // b不再需要style-loader要已经分离处理 MiniCssExtractPlugin.loader, "css-loader", // 编译css "postcss-loader", "sass-loader" // 编译scss ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: "[name].css", chunkFilename: "[id].css" &#125;) ]&#125; 3、代码分割按需加载、提取公共代码为什么要实现按需加载？我们现在看到，打包完后，所有页面只生成了一个bundle.js,当我们首屏加载的时候，就会很慢。因为他也下载了别的页面的js了,也就是说，执行完毕之前，页面是完全空白的。 如果每个页面单独打包自己的js，就可以在进入页面时候再加载自己的js，首屏加载就可以快很多12345optimization: &#123; splitChunks:&#123; chunks:&apos;all&apos; &#125;&#125; 4、文件压缩webpack4只要在生产模式下，代码就会自动压缩1mode: &apos;production&apos; 5、使用外部扩展(全局变量)可以直接在全局使用定义的$变量12345678910import Webpack from &apos;webpack&apos;externals: &#123; &apos;$&apos;: &apos;jquery&apos; //npm包 //需要require(&apos;$&apos;) &#125;//或者plugins: [new Webpack.ProvidePlugin(&#123; $: &apos;jquery&apos;, // npm jQuery: &apos;jQuery&apos; // 本地Js文件&#125;)] 6、指定环境,定义环境变量1234567891011import Webpack from 'webpack'&#123; plugins: [ new webpack.DefinePlugin(&#123; 'process.env': &#123; VUEP_BASE_URL: JSON.stringify('http://localhost:8080') &#125; &#125;), ]&#125; 7、CSS Tree Shaking1234567891011121314yarn add glob-all purify-css purifycss-webpack const PurifyCSS = require(&apos;purifycss-webpack&apos;)const glob = require(&apos;glob-all&apos;)plugins:[ // 清除无用 css new PurifyCSS(&#123; paths: glob.sync([ // 要做 CSS Tree Shaking 的路径文件 path.resolve(__dirname, &apos;./src/*.html&apos;), // 请注意，我们同样需要对 html 文件进行 tree shaking path.resolve(__dirname, &apos;./src/*.js&apos;) ]) &#125;)] 8、js Tree Shaking清除到代码中无用的js代码，只支持import方式引入，不支持commonjs的方式引入只要mode是production就会生效，develpoment的tree shaking是不生效的，因为webpack为了方便你的调试123optimization: &#123; usedExports:true, &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue通信]]></title>
    <url>%2Fblog%2F2019%2F06%2F12%2FVue%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[props和$emitprops父传子，$emit子传父123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 Vue.component('child',&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; &lt;/div&gt; `, props:['message'],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit('getChildData',val) &#125; &#125; &#125;)//┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child :message="message" v-on:getChildData="getChildData"&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:'张不怂' &#125; &#125;, methods:&#123; //执行子组件触发的事件 getChildData(val)&#123; console.log(val) &#125; &#125; &#125;)//┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ // 挂载 var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 中央事件总线new Bus新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859Vue.component('brother1',&#123; data()&#123; return &#123; mymessage:'hello brother1' &#125; &#125;, template:` &lt;div&gt; &lt;p&gt;this is brother1 compoent!&lt;/p&gt; &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; &lt;/div&gt; `, methods:&#123; passData(val)&#123; //触发全局事件globalEvent bus.$emit('globalEvent',val) &#125; &#125; &#125;) //┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ Vue.component('brother2',&#123; template:` &lt;div&gt; &lt;p&gt;this is brother2 compoent!&lt;/p&gt; &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, data()&#123; return &#123; mymessage:'hello brother2', brothermessage:'' &#125; &#125;, mounted()&#123; //绑定全局事件globalEvent bus.$on('globalEvent',(val)=&gt;&#123; this.brothermessage=val; &#125;) &#125; &#125;)//┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ //中央事件总线 var bus=new Vue(); var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt; &lt;/div&gt; ` &#125;) provide和inject父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。123456789101112131415161718192021222324252627282930313233Vue.component('child',&#123; inject:['parent_var'],//得到父组件传递过来的数据 data()&#123; return &#123; mymessage:this.parent_var &#125; &#125;, template:` &lt;div&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#125;)//┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┄┅┄┅┄┅┄┅┄＊ Vue.component('parent',&#123; template:` &lt;div&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, provide:&#123; /* 比如你可以把用户登录信息存储在App.vue中，可以把 provide:&#123;app:this&#125;注入，后续所有组件通过inject:['app'], 就可以直接通过app.userInfo拿到用户信息 */ parent_var:'随便什么都可以（可以是this,可以是data中的数据）' &#125;, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) $attrs和$listeners还是多层的场景，App.vue–&gt;A—&gt;B,如果App直接想给B传递数据该怎么办？Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件App直接传递数据给组件Bapp.vue引入A组件123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="app"&gt; &#123;&#123;app&#125;&#125; // ******关键点***** &lt;A :app="app" @test="doTest"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import A from "./components/A";export default &#123; name: "App", data() &#123; return &#123; app: "我是App的数据" &#125;; &#125;, components: &#123; A &#125;, methods: &#123; doTest() &#123; console.log(this.app) &#125; &#125;&#125; A.vue引入B组件123456789101112131415161718192021222324&lt;template&gt; &lt;div class="hello"&gt; &lt;h6&gt;这里是A组件&lt;/h6&gt; &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt; &lt;p&gt;$listeners: &#123;&#123;$listeners&#125;&#125;&lt;/p&gt; // ******关键点***** v-bind传递的都是$attrs,v-on传递的都是$listeners &lt;B v-bind="$attrs" v-on="$listeners"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import B from "./B";export default &#123; name: "A", props: &#123; msg: String &#125;, components: &#123; B &#125;, mounted() &#123; console.log(this.$listeners); &#125;&#125;;&lt;/script&gt; B组件1234567891011121314151617181920212223&lt;template&gt; &lt;div class="hello"&gt; &lt;h6&gt;这里是B组件&lt;/h6&gt; // ******关键点***** &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: "B", props: &#123; msg: String &#125;, mounted() &#123; // ******关键点***** // 为啥这里直接能emitApp组件传递的test呢？ // 因为在A组件中有一个关键操作是 &lt;B v-bind="$attrs" v-on="$listeners"/&gt; this.$emit("test"); &#125;&#125;;&lt;/script&gt; $parent和$children分别是获得父组件和子组件的实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546Vue.component('child',&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$parent.message = this.mymessage;//通过如此调用可以改变父组件的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; &lt;/div&gt; &#125;) Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;button @click="changeChildValue"&gt;test&lt;/button &gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, methods:&#123; changeChildValue()&#123; this.$children[0].mymessage = 'hello'; &#125; &#125;, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) v-model父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值1234567891011121314151617181920212223242526272829303132333435363738394041Vue.component('child',&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$emit('input',this.mymessage); //通过如此调用可以改变父组件上v-model绑定的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; &lt;/div&gt; &#125;) Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;child v-model="message"&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) Vue.observable()vue2.6之前，创建一个响应对象，必须在一个Vue实例中配置。现在我们可以在Vue实例外部，通过使用Vue.observable(data)创建，如下12345678910111213141516import vue from vue;const state = Vue.observable (&#123; counter: 0,&#125;);export default &#123; render () &#123; return ( &lt;div&gt; &#123;state.counter&#125; &lt;button v-on:click=&#123;() =&gt; &#123;state.counter ++; &#125;&#125;&gt; Increment counter &lt;/ button&gt; &lt;/ div&gt; ); &#125;,&#125;; vuex具体参考文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue数据更新问题]]></title>
    <url>%2Fblog%2F2019%2F06%2F11%2FVue%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Vue 的数组更新问题 以下参考 Vue 文档 由于 JavaScript 的限制，Vue 不能检测以下数组的变动： 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 2.当你修改数组的长度时，例如：vm.items.length = newLength 题外话 实际上，我们在 Vue 的数组书使用 splice、push等方法，Vue 都已经做了一层封装，所以它们才能出发视图更新，如果有想更加深入了解，可以阅读源码。 Vue 强制刷新——$forceUpdate() 如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。 类似的代码如下：123456// 在控制变量改变的时候进行 强制渲染更新let childrenRefs = this.$refs.elTabs.$childrenthis.$nextTick(() =&gt; &#123; childrenRefs.forEach(child =&gt; child.$forceUpdate())&#125;) 深拷贝数据先用一个数据深拷贝数据，这里使用了 slice 方法，然后置空，最后在 $nextTick 中赋值深拷贝出来的数组值。12345var newArray = this.questionData.slice(0)this.questionData = []this.$nextTick(function () &#123; this.questionData = newArray;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[gulp配置react开发环境]]></title>
    <url>%2Fblog%2F2019%2F05%2F25%2Fgulp%E9%85%8D%E7%BD%AEreact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[gulp与webpackgulp是对文件的处理,是Task Runner,节省了手动编译,手动打包这一步,但是单纯使用gulp没法去解决js中引入module的问题,可能会遇到项目中明明引入了babel语法转换,为什么浏览器会提示require is not defined报错,这是因为babel只解析语法,并不会去管js的模块引入。而webpack解决了require的问题,根据不同的文件转换需求引入不同的loader,最后打包出符合相应规则的静态资源文件。 Browserify-让浏览器加载Node模块 官方文档开头介绍:require(&#39;modules&#39;) in the browser 目前NPM的包大多都是通过CMD的方式打包的，除了特定的可以使用CMD模块加载器加载的模块，大部分nodejs模块无法直接使用到浏览器环境中。Browserify是一个供浏览器环境使用的模块打包工具，像在node环境一样，也是通过require(‘modules’)来组织模块之间的引用和依赖，既可以引用npm中的模块，也可以引用自己写的模块，然后打包成js文件，再在页面中通过&lt;script&gt;标签加载。 Browserify.transform指定转换模块,在打包过程中自动执行,在这里需要结合babel进行语法转换 详细配置react语法解析主要用到babel的@babel/preset-react插件,此外还会使用到browserSync进行自动检测刷新,less预处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const gulp = require('gulp') //引入gulpconst less = require('gulp-less') //引入gulp-less处理less语法const LessAutoprefix = require('less-plugin-autoprefix') //css兼容前缀const autoprefix = new LessAutoprefix(&#123; browsers: ['last 2 versions']&#125;)const del = require('del') //删除文件模块,在每次gulp任务前执行const babel = require('gulp-babel') //babelconst browserSync = require('browser-sync').create() //自动刷新const reload = browserSync.reload //reload示例,用于浏览器刷新const browserify = require('browserify') //模块处理const source = require('vinyl-source-stream') //将browerify流转换成gulp文件流const babelify = require('babelify') //用于browserify的babel编译器//主任务function main(cb) &#123; (async () =&gt; &#123; await del.sync('dist') //less gulp.src('./src/index.less').pipe(less(&#123; plugins: [autoprefix] &#125;)).pipe(gulp.dest('./dist')) //js browserify(&#123; entries:['./src/index.js'] &#125;) .transform(babelify,&#123; presets: ['@babel/env','@babel/preset-react'], plugins: ["@babel/plugin-transform-runtime"] &#125;) .bundle() //打包 .pipe(source('index.js')).pipe(gulp.dest('./dist')) gulp.src('./src/index.html').pipe(gulp.dest('./dist')) cb() &#125;)()&#125;//开发环境function devServer(cb)&#123; browserSync.init(&#123; server: &#123; baseDir: './dist' &#125; &#125;) gulp.watch("./src/**", gulp.series(lessChange,jsChange,htmlChange)) cb()&#125;//检测html变化function htmlChange()&#123; return gulp.src('./src/index.html').pipe(gulp.dest('./dist')).pipe(reload(&#123;stream:true&#125;))&#125;//检测样式文件function lessChange() &#123; return gulp.src('./src/index.less').pipe(less(&#123; plugins: [autoprefix] &#125;)).pipe(gulp.dest('./dist')).pipe(reload(&#123;stream:true&#125;))&#125;//检测js文件function jsChange(cb)&#123; browserify(&#123; entries:['./src/index.js'] &#125;) .transform(babelify,&#123; presets: ['@babel/env','@babel/preset-react'], plugins: ["@babel/plugin-transform-runtime"] &#125;) .bundle() .pipe(source('index.js')).pipe(gulp.dest('./dist')).pipe(reload(&#123;stream:true&#125;)) cb()&#125;//default默认任务,用于package.json执行脚本gulp任务gulp.task('default', gulp.series(main,devServer))]]></content>
  </entry>
  <entry>
    <title><![CDATA[指数运算性能比较]]></title>
    <url>%2Fblog%2F2019%2F04%2F08%2F%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[自定义递归函数1234function calculateExponent(base,exponent)&#123; if(exponent == 1) return base return base * calculateExponent(base,--exponent)&#125; Math.pow()Math.pow() 函数返回基数（base）的指数（exponent）次幂，即 base^exponent。 ES7指数操作符在ES7中引入了指数运算符**12 ** 2 // 4 比较性能(测试环境 v8)比较使用console.time和console.timeEnd方法,得出运算耗时123456789101112131415161718//依次比较10次幂,100次幂,1000次幂,10000次幂循环100次耗时console.time()for(let i =0;i&lt;100;i++)&#123; calculateExponent(i,10)&#125;console.timeEnd()console.time()for(let i =0;i&lt;100;i++)&#123; Math.pow(i,10)&#125;console.timeEnd()console.time()for(let i =0;i&lt;100;i++)&#123; i ** 10&#125;console.timeEnd() 结果得出四次结果耗时1234[&apos;10&apos;, 0.2, 0.052, 0.052],[&apos;100&apos;, 0.503, 0.057, 0.089],[&apos;1000&apos;, 3.273, 0.090, 0.083],[&apos;10000&apos;, 28.346, 0.081, 0.120] 可以发现递归函数时间大大多于其他两个方法,那么剔除递归函数的结果再看: 根据图可以发现,两个方法在不同数量级耗费的时间有长有短,在1000数量级时候**运算符时间却少于Math.pow,来到10000数量级时**运算符时间大幅度长于Math.pow,我们可以根据实际情况选择使用**还是Math.pow]]></content>
  </entry>
  <entry>
    <title><![CDATA[实现小程序拖拽排序]]></title>
    <url>%2Fblog%2F2019%2F03%2F27%2F%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[实现效果这是最近我做的一个需求,由于产品项目模块众多,达近80个模块,所以有了这个模块管理排序的需求,得益于小程序自带的组件movable-view(基础库 1.2.0 开始支持),使得拖拽这一交互效果的实现变得优雅。在这里记录下写这个模块的一些心得 核心方法有三个核心方法,分别是bindchange事件(movable-view自带事件,类似于touchmove事件),touchend事件,touchstart事件核心代码:12345678910111213141516touchStart(index, fatherIndex) &#123; this.clientX = null this.clientY = null&#125;,touchMoving(index, fatherIndex, event) &#123; this.clientX = event.detail.x + (this.moveAreaWidth / 4 / 2) //this.moveAreaWidth每个modal this.clientY = event.detail.y + ITEM_HEIGHT / 4&#125;,touchEnd(index, fatherIndex) &#123; if (this.clientX &amp;&amp; this.clientY) &#123; const row = Math.floor(this.clientY / (ITEM_HEIGHT / 2)) const column = Math.floor(this.clientX / (this.moveAreaWidth / 4)) const newIndex = row * 4 + column index == newIndex ? this.hasChangedSort = false : (this.hasChangedSort = true,this.handleDragEnd(index, fatherIndex, newIndex)) &#125;&#125; 在这里,touchStart事件初始化每次拖拽后设定的clientX,clientX值touchmove事件中需要处理这样一件事,根据每个模块的高度以及宽度(需要通过小程序APIwx.createSelectorQuery计算得出)实时计算出落点所在的x,y坐标,最后touchend事件计算出x,y坐标所对应的行列数,根据行列数计算出当前模块所在对应数组中的索引序列(handleDragEnd方法),在data数据源数组中替换两个模块数据的索引下标 遇到的问题由于直接改变索引下标会造成瞬闪现象,就是拖拽完成后模块会先在原来位置闪现一下再回到拖拽后的位置,这是因为操作数据会直接改变视图,所以我们需要一个延时操作$nextTick,在这个延时方法中去操作新位置模块的x,y坐标,就可以解决这个问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java链表基本功能实现]]></title>
    <url>%2Fblog%2F2019%2F03%2F05%2FJava%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[链表链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 接口一个基本的Java链表主要有一下的功能: add首先,新建一个List类,以及一个Node类,通过List类来调用方法123456789101112131415161718192021public class List&#123; private Node root;//定义链表的根节点 private int count = 0;//定义当前列表节点个数&#125;public class Node&#123; private String data;//这是一个数据类型是 String 的链表 private Node next; //每个Node类需要一个指向当前Node的下一个Node,才行形成链关系 pulic Node(String data)&#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public String getData() &#123; return data; &#125;&#125; 定义完基本数据类,我们来实现add方法在List中定义add1234567891011public void add(String data)&#123; Node newNode = new Node(data); if(this.root == null)&#123; this.root = newNode; &#125; else&#123; this.root.addNode(newNode,this); //我们需要传入当前list对象,用于新增节点后跟新count &#125;&#125; public void addCount() &#123; this.count++;&#125; Node类中实现addNode,它接受一个Node类型参数12345678910111213141516171819public void addNode(Node newNode,List list)&#123; if(!this.equals(newNode))&#123; if(this.next == null)&#123; this.next = newNode; list.addCount(); &#125; else &#123; //如果当前下个节点不为空,则让next继续调用addNode方法 this.next.addNode(newNode,list); &#125; &#125;&#125;//为了做到不重复新增数据,我们需要在Node类中实现一个equals方法public boolean equals(Node node)&#123; if(this.data == node.data)&#123; return true; &#125; return false;&#125; getget方法接受一个int类型的序号,用于找到当前类型对应位置的节点数据,在List类中定义get1234public String get(int index) &#123; if (this.root == null) return null; return this.root.get(index, 0);&#125; Node类中定义getNode方法,它除了接受index参数外,还接受一个步进参数step,用于匹配index是否等于当前step1234public String get(int index, int step) &#123; if (index == step) return this.data; return this.next.get(index, ++step);&#125; setset方法用于重新设置链表对应位置节点的数据,1234public void set(int index, String data) &#123; if (this.root == null || index &lt; 0 || index &gt; this.count) return; this.root.setNode(index, data, 0);&#125; containscontains方法返回一个Boolean,判断当前列表是否存在对应的数据12345//Listpublic boolean contains(String data) &#123; if (this.root == null) return false; return this.root.containNode(data);&#125; 在Node类中定义containNode方法123456789//Nodepublic boolean containNode(String data) &#123; if (this.data.equals(data)) &#123; return true; &#125; else &#123; if (this.next == null) return false; return this.next.containNode(data); &#125;&#125; size返回当前链表节点个数1234//Listpublic int size() &#123; return this.count;&#125; isEmpty判断当前链表是否为空123public boolean isEmpty() &#123; return this.count == 0;&#125; remove删除节点数据123456789101112131415//Listpublic void remove(String data) &#123; if (this.root == null) return; if (this.root.equals(data)) &#123; //根节点特殊处理 this.root = this.root.getNext(); this.count--; &#125; else &#123; this.root.removeNode(this.root, data,this); &#125;&#125;//同add操作,还需要另外定义一个reduceCount方法供Node实例调用public void reduceCount() &#123; this.count--;&#125; Node类中定义removeNode12345678910//Nodepublic void removeNode(Node pre, String data, List list) &#123; if (this.data.equals(data)) &#123; pre.next = this.next; list.reduceCount(); &#125; else &#123; if(this.next != null) this.next.removeNode(this, data,list); &#125; &#125; toArray将当前链表输出为array数组对象12345678//List 新增一个私有属性arrayListprivate String[] arrayList;publice String[] toArray()&#123; this.arrayList = new String[this.count]; this.root.toArrayNode(arrayList,0); return this.arrayList;&#125; Node类中定义toArrayNode方法1234567//Nodepublic void toArrayNode(String [] array,int step)&#123; array[step] = this.data; if(this.next != null)&#123; this.next.toArrayNode(array,++step); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端组件化开发]]></title>
    <url>%2Fblog%2F2019%2F02%2F18%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[什么是组件化开发 前端组件化开发，就是将页面的某一部分独立出来，将这一部分的 数据层（M）、视图层（V）和 控制层（C）用黑盒的形式全部封装到一个容器内，暴露出一些开箱即用的函数和属性供外部组件调用。 怎么设计一个组件 单一一个组件的功能是单一的,应该只做一件事。一个功能如果可以拆分成多个功能点，那就可以将每个功能点封装成一个组件，当然也不是组件的颗粒度越小越好，只要将一个组件内的功能和逻辑控制在一个可控的范围内即可。 与业务逻辑解耦一个组件应该是纯粹,不参杂业务逻辑的,当涉及到业务时,如日期选择组件,产品要求日期小于当日的不可以选择,否则弹出提示框提示用户,这是我们就应该通过传入的配置参数,来进行判断,如果开启不能选择小于当前日期配置的话,当用户点击不符合要求的日期时,通过组件事件传递,将该事件告知父组件,由父组件进行业务逻辑的处理。 可配置在一开始设计组件的时候就应该结合业务需求考虑哪些功能应该做成可配置式的,如干警端src/components/noResultComponent(用于空数据时的展示),默认的文案是暂无数据,但是在有时候刚进入页面时,此时网络正在请求数据,页面此时用暂无数据就不太合适,这时候可以传正在加载来告知用户,此时正在请求数据过程中请等待。 属性值的检验1.传入属性是否合法2.属性是否必传 在wepy中进行类型检查:123456props = &#123; text: &#123; type: String, default: '正在加载' &#125; &#125; Vue中类型检查1234567props = &#123; someprop: &#123; type: String, default: 'someText', required: true &#125; &#125; React中进行类型检查12345678910import React from 'react'import PropTypes from 'prop-types'class MyComponent extends React.Component &#123; render() &#123; // ... do things with the props &#125;&#125;MyComponent.propTypes = &#123; someProps:PropTypes.string.isRequired&#125; 组件生命周期 初始化阶段,读取属性值,并进行处理 展示阶段,监听属性变化,进行相应逻辑处理 组件销毁阶段,及时移除组件中对整个系统产生副作用的操作,如addEventListener,setInterval等等。 在小程序中定义组件生命周期123456789101112131415161718Component(&#123; lifetimes: &#123; attached() &#123; // 在组件实例进入页面节点树时执行 &#125;, detached() &#123; // 在组件实例被从页面节点树移除时执行 &#125;, &#125;, // 以下是旧式的定义方式，可以保持对 &lt;2.2.3 版本基础库的兼容 attached() &#123; // 在组件实例进入页面节点树时执行 &#125;, detached() &#123; // 在组件实例被从页面节点树移除时执行 &#125;, // ...&#125;) 事件传递 在wepy中,wepy.component基类提供$broadcast、$emit、$invoke三个方法用于组件之间的通信和交互在Vue中,子组件通过this.$emit发送,父组件只需监听该发送的事件即可在’React’中,父组件可以使用 props 向子组件传值，而子组件向父组件传值，需要在父组件内定义函数并通过属性传递给子组件，在子组件内通过调用该属性对应的函数，传入参数，传递给父组件内的函数，并在父组件的该函数中做逻辑的处理。12345678910111213141516171819202122232425262728//子组件class ChildComponent extends React.Components &#123; render() &#123; return ( &lt;button onClick=&#123; () =&gt; &#123; this.props.clickHandler('This is a click') &#125; &#125;&gt;&lt;/button&gt; ) &#125;&#125;//父组件import ChildComponent from './child-component'class ParentComponent extends React.Components &#123; clickHandler(message) &#123; console.log(message) &#125; render() &#123; return ( &lt;child-component clickHandler=&#123; this.clickHandler.bind(this) &#125; /&gt; ) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJs实现基本拖拽]]></title>
    <url>%2Fblog%2F2019%2F01%2F04%2FRxJs%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[HTML123456789&lt;div id="anchor"&gt; &lt;div class="video" id="video"&gt; &lt;video width="100%" height="100%" controls &gt; &lt;source src="http://download.blender.org/peach/bigbuckbunny_movies/big_buck_bunny_480p_stereo.ogg" type="video/ogg"&gt; Your browser does not support HTML5 video. &lt;/video&gt; &lt;/div&gt;&lt;/div&gt; CSS12345678910111213141516171819202122232425262728293031323334353637383940&lt;style&gt; * &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; html, body &#123; margin: 0; padding: 0; height: 2000px; background-color: #eee; &#125; #anchor &#123; height: 360px; width: 100%; background-color: #F0F0F0; &#125; .video &#123; width: 640px; height: 360px; margin: 0 auto; background-color: black; &#125; .video.video-fixed &#123; position: fixed; top: 10px; left: 10px; width: 320px; height: 150px; cursor: all-scroll; &#125; .video.video-fixed .masker &#123; display: none; &#125; .video.video-fixed:hover .masker &#123; display: block; position: absolute; width: 100%; height: 180px; background-color: rgba(0, 0, 0, 0.8); z-index: 2; &#125; &lt;/style&gt; JS12345678910111213141516171819202122232425262728293031323334 import &#123;Observable&#125; from 'rxjs/Rx' const $video = document.querySelector('#video')const $anchor = document.querySelector('#anchor')const scroll = Observable.fromEvent(document, 'scroll'). //监听document事件 map(e =&gt; $anchor.getBoundingClientRect().bottom &lt; 0). //map将event事件映射为判断式布尔值 subscribe(bool =&gt; &#123; //如果当前元素不在视窗内,则改变样式 if(bool)&#123; $video.classList.add('video-fixed') &#125;else&#123; $video.classList.remove('video-fixed') $video.style.transform = '' &#125; &#125;)const mouseDown = Observable.fromEvent($video, 'mousedown') //observe事件const mouseMove = Observable.fromEvent(document, 'mousemove')const mouseUp = Observable.fromEvent(document, 'mouseup')const videoBoundingRect = $video.getBoundingClientRect() //获取viedo元素rect对象const validValue = (value,max,min)=&gt;&#123; //比较函数,防止拖拽出屏幕 return Math.min(Math.max(value,min),max)&#125;mouseDown.filter(e =&gt; $video.classList.contains('video-fixed')). //filter过滤 switchMap(e =&gt; mouseMove.takeUntil(mouseUp)). //将高阶Oberve转换为低阶 withLatestFrom(mouseDown, (move, down) =&gt; &#123; //结合上一个observable源的结果 return &#123; //move.clientX - down.offsetX =&gt;处理抖动 x: validValue(move.clientX - down.offsetX,window.innerWidth - videoBoundingRect.width/2,0), y: validValue(move.clientY - down.offsetY,window.innerHeight - videoBoundingRect.height/2,0), &#125; &#125;). subscribe(e =&gt; &#123; $video.style.transform = `translate3D($&#123;e.x&#125;PX,$&#123;e.y&#125;px,0)` &#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxJs初探]]></title>
    <url>%2Fblog%2F2018%2F12%2F29%2FRxJs%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[RxJSRxJS 是使用 Observables 的响应式编程的库，它使编写异步或基于回调的代码更容易。 简单demo使用rx.js实现一个canvas画板html1&lt;canvas&gt;&lt;/canvas&gt; 12345678910111213141516171819202122232425import &#123;Observable&#125; from 'rxjs/Rx' //引入rx Observable对象const canvas = document.querySelector('canvas')const ctx = canvas.getContext('2d') //获取canvas画笔ctx.beginPath()function drawEvent([first, sec]) &#123; ctx.moveTo(first.x, first.y) ctx.lineTo(sec.x, sec.y) ctx.stroke() &#125;const moveEvent = Observable.fromEvent(canvas,'mousemove') .map(e =&gt;&#123;x:e.offsetX,y:e.offsetY&#125;) .bufferCount(2,1) //定义move流 const downEvent = Observable.fromEvent(canvas,'mousedown').map(()=&gt;'down') //将Observable 结果映射为'down' //这里我们可以将Observable想象成一个数组,将数组的map方法类似于这里的map方法 const upEvent = Observable.fromEvent(canvas,'mouseup').map(()=&gt;'up') //将Observable 结果映射为'up' const upAndDown = downEvent.merge(upEvent) //融合两个Observable upAndDown.switchMap(e=&gt;e==='down'?moveEvent:Observable.empty()).subscribe(drawEvent) //subscribe: 注册处理程序的订阅引用 //因为事件处理流可能是异步的,我们不必在等待事件执行成功后再继续下一步操作,而是订阅一个注册事件,事件执行后再通知给订阅者 总结这只是一个简单的demo,用于展示RxJS的基本思想,一个面向过程的基本思想。]]></content>
  </entry>
  <entry>
    <title><![CDATA[摘录]]></title>
    <url>%2Fblog%2F2018%2F12%2F15%2F%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[你在池塘里活得很好，泥鳅很丑但会说喜庆话，癞蛤蟆很马虎但很有趣，田螺是个温柔的自闭症，小鲫鱼是你们共同的女神。有一天你听说，江河湖海，哪个都要更大，更好。你跳了出去，遇见了美丽的海豚，雄壮的白鲸，婀娜多姿的热带鱼，的确都是好的。就是偶尔，觉得世界很空，生活很咸。——姬霄]]></content>
  </entry>
  <entry>
    <title><![CDATA[event-bus发布订阅实现]]></title>
    <url>%2Fblog%2F2018%2F12%2F12%2Fevent-bus%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一个简单的实现了事件注册,订阅,注销的eventEmeitter 12345678910111213141516171819202122232425262728293031323334353637383940class EventEmeitter&#123; constructor()&#123; this._events = new Map() &#125; emit(type,context,...args)&#123; const handler = this._events.get(type) if(typeof handler !== 'function')&#123; throw Error(`[$&#123;type&#125;] 未绑定事件`) &#125; if(args.length &gt;= 3)&#123; handler.apply(context,args) &#125;else&#123; handler.call(context,...args) &#125; &#125; addEventListener(type,fn)&#123; if(!this._events.get(type))&#123; this._events.set(type,fn) console.log(`[$&#123;type&#125;] 事件绑定`) &#125;else&#123; throw Error(`[$&#123;type&#125;] 事件已绑定`) &#125; &#125; removeEventListener(type)&#123; this._events.delete(type) console.log(`[$&#123;type&#125;] 事件移除`) &#125;&#125;const emitter = new EventEmeitter()emitter.addEventListener('christmas',s=&gt;&#123; console.log(`Merry $&#123;s&#125;`)&#125;)emitter.emit('christmas',this,'Christmas')emitter.removeEventListener('Christmas')---[christmas] 事件绑定Merry Christmas[Christmas] 事件移除]]></content>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2Fblog%2F2018%2F12%2F05%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 第一次解法:12345678910var twoSum = function(nums, target) &#123; for(let i=0;i&lt;nums.length;i++)&#123; var result = targer - nums[i] var resultIndex = nums.indexOf(result) if(resultIndex &gt; -1 &amp;&amp; resultIndex !== i)&#123; return [i,resultIndex] &#125; &#125;&#125;执行用时:196ms hashMap:1234567891011var twoSum = function(nums, target) &#123; var map = new Map() for(let i=0;i&lt;nums.length;i++)&#123; var result = target - nums[i] if(map.has(result))&#123; return [map.get(result),i] &#125; map.set(nums[i],i) &#125;&#125;执行用时:80ms]]></content>
  </entry>
  <entry>
    <title><![CDATA[几种移动端rem布局解决方案]]></title>
    <url>%2Fblog%2F2018%2F11%2F21%2F%E5%87%A0%E7%A7%8D%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[rem概念rem是一种css单位,通常用于解决移动端各个手机显示适配问题,保证UI设计在不同手机,不同设备之间显示效果的一致性。它是相对于html根元素的字体大小而定,比如设定根元素字体大小font-size:16px,那么1rem = 16px viewportviewport是专为手机浏览器设计的一个meta标签； 有些屏幕很小有智能手机，但分辩率却可以做得很大，比如某些手机的默认分辨率为：1920*1080，比许多电脑桌面的都还大，传统桌面网站直接放到手机上阅读时，界面就会显得非常小，阅读体验就很差，就样就需要一种将原始视图在手机上放大的机制，使用viewport标签可以解决这个问题，如123456&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;initial-scale：初始缩放比例maximum-scale：允许缩放的最大比例minimum-scale：允许缩放的最小比例user-scalable：是否允许手动缩放 阿里解决方案(1rem = 100px)把下面这段已压缩过的原生JS放到HTML的 head 标签中即可（注:不要手动设置viewport，该方案自动帮你设置）1&lt;script&gt;!function(e)&#123;function t(a)&#123;if(i[a])return i[a].exports;var n=i[a]=&#123;exports:&#123;&#125;,id:a,loaded:!1&#125;;return e[a].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports&#125;var i=&#123;&#125;;return t.m=e,t.c=i,t.p=&quot;&quot;,t(0)&#125;([function(e,t)&#123;&quot;use strict&quot;;Object.defineProperty(t,&quot;__esModule&quot;,&#123;value:!0&#125;);var i=window;t[&quot;default&quot;]=i.flex=function(normal,e,t)&#123;var a=e||100,n=t||1,r=i.document,o=navigator.userAgent,d=o.match(/Android[\S\s]+AppleWebkit\/(\d&#123;3&#125;)/i),l=o.match(/U3\/((\d+|\.)&#123;5,&#125;)/i),c=l&amp;&amp;parseInt(l[1].split(&quot;.&quot;).join(&quot;&quot;),10)&gt;=80,p=navigator.appVersion.match(/(iphone|ipad|ipod)/gi),s=i.devicePixelRatio||1;p||d&amp;&amp;d[1]&gt;534||c||(s=1);var u=normal?1:1/s,m=r.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;);m||(m=r.createElement(&quot;meta&quot;),m.setAttribute(&quot;name&quot;,&quot;viewport&quot;),r.head.appendChild(m)),m.setAttribute(&quot;content&quot;,&quot;width=device-width,user-scalable=no,initial-scale=&quot;+u+&quot;,maximum-scale=&quot;+u+&quot;,minimum-scale=&quot;+u),r.documentElement.style.fontSize=normal?&quot;50px&quot;: a/2*s*n+&quot;px&quot;&#125;,e.exports=t[&quot;default&quot;]&#125;]); flex(false,100, 1);&lt;/script&gt; 网易解决方案(1rem = 100px)123456789101112131415161718192021222324252627282930313233var win=windowwin.resize = &#123;&#125;; var timer = null; var rem = 12; var doc = win.document; var docEl = doc.documentElement; /** * 刷新页面REM值 */ function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; width = width &gt; 768 ? 640 : width; rem = width / 7.5; docEl.style.fontSize = rem + 'px'; &#125; /** * 页面缩放或重载时刷新REM */ win.addEventListener('resize', function () &#123; clearTimeout(timer); timer = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; clearTimeout(timer); timer = setTimeout(refreshRem, 300); &#125; &#125;, false); refreshRem(); 美团解决方案(1rem = 100px)1234567891011121314151617(function () &#123; function o() &#123; document.documentElement.style.fontSize = (document.documentElement.clientWidth &amp;&amp; document.documentElement.clientWidth &lt; 768 ? document.documentElement.clientWidth : 768) / 7.5 + "px" &#125; var e = null; window.addEventListener("resize", function () &#123; clearTimeout(e), e = setTimeout(o, 300) &#125;, !1), o() //3秒后检查如果html fontSize为0，手动触发计算fontSize。 setTimeout(function () &#123; if (parseInt(document.defaultView.getComputedStyle(document.documentElement).fontSize) == 0) &#123; o(); &#125; &#125;, 3000);&#125;)(window) 纯css方案12345html &#123; width: 100%; max-width:768px; font-size:calc(100vw/7.5);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[gulp配置示例]]></title>
    <url>%2Fblog%2F2018%2F11%2F20%2Fgulp%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Gulp是什么Gulp是一个基于流的构建工具，可以自动执行指定的任务，简洁且高效 Gulp能做什么 开发环境下，想要能够按模块组织代码，监听实时变化 css/js预编译，postcss等方案，浏览器前缀自动补全等 条件输出不同的网页，比如app页面和mobile页面 线上环境下，我想要合并、压缩 html/css/javascritp/图片，减少网络请求，同时降低网络负担 等等… gulp配置示例以及注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/******************************************************* gulp 组件 及 gulp task******************************************************/const gulp = require('gulp'); //引入gulpconst source = require('vinyl-source-stream'); //加载vinyl文件流处理const browserify = require('browserify'); //加载预编译browserSyncconst browserSync = require('browser-sync'); //实时更新插件const buffer = require('vinyl-buffer');const babel = require('babelify'); //babel语法转化const reload = browserSync.reload;const sourcemaps = require('gulp-sourcemaps'); //生成sourcemap文件const del = require('del'); //引入删除模块const argv = require('yargs').argv; // 引入参数 根据参数的不同 执行相应的任务 s 生产环境 p 测试环境 d 开发环境const __ = require('gulp-load-plugins')(); //可以不用引入 直接使用已经在package.json里的插件//先预定好各个元素的路径const domSrc = &#123; //js 路径 jsSrc: 'app/js/**/*.js', //js 库路径 jsLibsSrc: 'app/js/libs/**/*.js', //jquery 文件 jquerySrc:'app/js/libs/jquery/*.js', //config js路径 configSrc: 'app/js/config/*.js', //index路径 indexHtmlSrc: 'app/index.html', //页面路径 htmlSrc: 'app/**/*.html', //css路径 cssSrc: ['app/assets/**/*.css', 'app/assets/scss/app.scss'], //监听css路径 watchCssSrc: 'app/assets/**/*.&#123;css,scss&#125;', //监听css路径 //fonts路径 排除css文件 fontSrc: ['app/assets/fonts/*', '!app/assets/fonts/*.css'], //image路径 imgSrc: 'app/assets/images/**/*', //res路径 resSrc: 'app/assets/res/**/*', //dist 下的 JS distJsSrc: 'dist/js', //dist 下的 html distHtmlSrc: 'dist/html', //dist 下的 tpl distTplSrc: 'dist/tpl', //dist 下的css distCssSrc: 'dist/css', //dist 下的 fonts distFontsSrc: 'dist/fonts'&#125;//js 库文件 组文件 筛选const libsfilter = __.filter(domSrc.jsLibsSrc, &#123;restore: true, passthrough: false&#125;);//js 业务 文件 筛选const servicefilter = __.filter([domSrc.jsSrc, '!' + domSrc.jsLibsSrc], &#123;restore: true, passthrough: false&#125;);//html index.html 筛选const indexHtmlfilter = __.filter(domSrc.indexHtmlSrc, &#123;restore: true, passthrough: false&#125;);//配置configgulp.task('js:config', ()=&gt; &#123; var configSource = 'app/js/config/dev.js'; if (argv.s) &#123; //测试环境 configSource = 'app/js/config/staging.js'; &#125; else if (argv.p) &#123; //生产环境 configSource = 'app/js/config/prod.js'; &#125; return gulp.src(configSource) .pipe(__.rename('config.js')) .pipe(gulp.dest('app/js/config'));&#125;);//ES6 to ES5gulp.task('js:es6-2-es5', ()=&gt; &#123; return browserify(&#123;entries: 'app/js/myApp.js'&#125;) .transform(babel) //&#123;presets: ["es2015"]&#125; .bundle() //.pipe(__.sourcemaps.init()) .pipe(source('myApp.js')) .pipe(__.if(argv.p, __.streamify(__.uglify()))) .pipe(__.rename(&#123;suffix: '.min'&#125;)) //.pipe(__.sourcemaps.write('./')) .pipe(gulp.dest('dist/js'));&#125;);//JS 拷贝 libs ,components 文件夹gulp.task('js:copy-libs', ()=&gt; &#123; return gulp.src([domSrc.jsLibsSrc,'!'+domSrc.jquerySrc]) //.pipe(__.sourcemaps.init()) .pipe(__.flatten()) //移除目录结构 .pipe(__.concat("applibs.js")) //合并 .pipe(__.uglify()) //压缩 .pipe(__.rename(&#123;suffix: '.min'&#125;)) //重命名 //.pipe(__.sourcemaps.write('./')) .pipe(gulp.dest('dist/js/libs'));&#125;);//解析HTMLgulp.task('html', ()=&gt; &#123; return gulp.src(domSrc.htmlSrc) .pipe(gulp.dest('dist/'))&#125;);//复制 fontsgulp.task('fonts', ()=&gt; &#123; return gulp.src(domSrc.fontSrc) .pipe(gulp.dest('dist/css'));&#125;);//复制 图片gulp.task('image', ()=&gt; &#123; return gulp.src(domSrc.imgSrc) .pipe(gulp.dest('dist/imgs'));&#125;);//复制 resgulp.task('res', ()=&gt; &#123; return gulp.src(domSrc.resSrc) .pipe(gulp.dest('dist/res'));&#125;);//解析并合并压缩cssgulp.task('css', ()=&gt; &#123; return gulp.src(domSrc.cssSrc) .pipe(__.if('*.scss', __.sass())) .pipe(__.concat('app.css')) .pipe( __.minifyCss()) .pipe(__.rename((path)=&gt; &#123; path.basename += '.min'; &#125;)) .pipe(gulp.dest('dist/css'));&#125;);//清除dist下的JS文件gulp.task('clean:js', ()=&gt; &#123; return del([domSrc.distJsSrc]);&#125;);//清除dist 下的html文件gulp.task('clean:html', ()=&gt; &#123; return del([domSrc.distHtmlSrc, domSrc.distTplSrc]);&#125;);//清除dist下的 css 文件gulp.task('clean:css', ()=&gt; &#123; return del([domSrc.distCssSrc]);&#125;);//清除dist 下的 fonts文件gulp.task('clean:fonts', ()=&gt; &#123; return del([domSrc.distFontsSrc])&#125;);//本地服务器gulp.task('server', ()=&gt; &#123; browserSync(&#123; // tunnel: true, open: false, port: 9996, server: &#123; baseDir: ['dist'], index: ['./html/index.html', 'index.html'] &#125; &#125;); //js gulp.watch([domSrc.jsSrc,"!"+domSrc.configSrc], gulp.series('js', reload)); //css gulp.watch(domSrc.watchCssSrc, gulp.series('css', reload)); //html gulp.watch(domSrc.htmlSrc, gulp.series('html', reload)); //image gulp.watch(domSrc.imgSrc, gulp.series('image', reload));&#125;);gulp.task('clean', gulp.parallel('clean:js', 'clean:html', 'clean:css', 'clean:fonts'));gulp.task('js', gulp.series('clean:js', 'js:config', 'js:es6-2-es5', 'js:copy-libs'));gulp.task('copy', gulp.parallel('html', 'fonts', 'image', 'res'));gulp.task('default', gulp.series('clean', 'copy', 'js', 'css', 'server'));gulp.task('build', gulp.series('clean', 'copy', 'js', 'css'));]]></content>
  </entry>
  <entry>
    <title><![CDATA[1px border边框实现]]></title>
    <url>%2Fblog%2F2018%2F11%2F16%2F1px%20border%E8%BE%B9%E6%A1%86%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[由于移动端手机像素密度的差异,1px宽度的边框在不同的DPI下展示会有差异,可以通过下面这个方法来解决1234567891011121314151617181920212223242526272829303132&lt;!--解决1px边框--&gt;&lt;!--@ SASS语法--&gt;@mixin border-1px($color)&#123; position: relative; &amp;:after&#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid $color; content: ''; &#125;&#125;&lt;!--然后设置 统一的类 缩放--&gt;@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) &#123; .border-1px&#123; &amp;:after&#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) &#123; .border-1px&#123; &amp;:after&#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[cron定时器写法]]></title>
    <url>%2Fblog%2F2018%2F11%2F14%2Fcron%E5%AE%9A%E6%97%B6%E5%99%A8%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[corn命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令,例如Jenkins定时任务等.123456789* * * * * *┬ ┬ ┬ ┬ ┬ ┬│ │ │ │ │ |│ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)│ │ │ │ └───── month (1 - 12)│ │ │ └────────── day of month (1 - 31)│ │ └─────────────── hour (0 - 23)│ └──────────────────── minute (0 - 59)└───────────────────────── second (0 - 59, optional) 在一个区域里填写多个数值的方法： 逗号（’,’）分开的值，例如：“1,3,4,7,8” 连词符（’-‘）指定值的范围，例如：“1-6”，意思等同于“1,2,3,4,5,6” 星号（’*’）代表任何可能的值。例如，在“小时域”里的星号等于是“每一个小时”，等等 示例12//每三小时准点执行一次cron: &apos;0 0 */3 * * *&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[async库parallel/parallelLimit介绍]]></title>
    <url>%2Fblog%2F2018%2F11%2F13%2Fasync%E5%BA%93parallel-parallelLimit%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[parallelasync.js是一个功能强大的node异步流程控制库,parallel是async中用来执行并行任务流程的一个方法,parallel(tasks,callbackopt)接收两个参数: Name Type Description tasks Array/Iterable/Object 一个用于遍历的数据类型 callback Function (可选)返回一个数组或者对象,参数(err,result) 123456789101112131415const parallel = require('async/parallel')const time = new Date().getTime()parallel([(callback)=&gt;&#123; setTimeout(()=&gt;&#123; callback(null,'one') &#125;,1200)&#125;,(callback)=&gt;&#123; setTimeout(()=&gt;&#123; callback(null,'two') &#125;,1000)&#125;],(err,results)=&gt;&#123; console.log('time cost:',new Date().getTime()-time) console.log(results)&#125;) 执行结果:12time cost: 1201[ &apos;one&apos;, &apos;two&apos; ] parallel会等到所有函数返回结果后再返回最终的结果数组,并且按照顺序返回,不会因为第二个函数setTimeout的时间比第一个短就先返回 parallelLimitparallelLimit基本功能和parallel是一样的,不过它新增一个参数,用来控制同时执行的函数数量 Name Type Description tasks Array/Iterable/Object 一个用于遍历的数据类型 limit number 异步操作的最大数量 callback Function (可选)返回一个数组或者对象,参数(err,result) 123456789101112131415const parallelLimit = require('async/parallelLimit')const time = new Date().getTime()parallelLimit([(callback)=&gt;&#123; setTimeout(()=&gt;&#123; callback(null,'one') &#125;,1200)&#125;,(callback)=&gt;&#123; setTimeout(()=&gt;&#123; callback(null,'two') &#125;,1000)&#125;],1,(err,results)=&gt;&#123; console.log('time cost:',new Date().getTime()-time) console.log(results)&#125;) 运行结果12time cost: 2205[&quot;one&quot;, &quot;two&quot;] 因为设置的limit是1,所以运行时间是所有运行时间之和]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用for,set,map实现数组去重]]></title>
    <url>%2Fblog%2F2018%2F11%2F13%2F%E4%BD%BF%E7%94%A8for-set-map%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重的场景在开发中还是经常遇见的,比如一个地图选房功能,在地图上标识一个区域,显示区域上的房型,移动区域后显示新增的房型以及原来还在区域内的房型保持不变,实现这一个场景,就需要得出每次不变的房型的数组,以及新增的房型的数组.一般的,后台返回的数据只是我们选中的区域的房型数据,我们要对数据进行加工处理. 构造数据让我们先来生成模拟数据,并打乱我们生成的数据,模拟真实情况123456789101112131415161718192021222324252627282930313233343536373839function generateHouses(n) &#123; //生成数据 let newHouse = new Array(n) let oldHouse = new Array(n) for (let i = 0; i &lt; n / 2; i++) &#123; newHouse[i] = oldHouse[i] = &#123; id: i &#125; &#125; for (let i = n / 2; i &lt; n; i++) &#123; newHouse[i] = &#123; id: n * 2 + i &#125; oldHouse[i] = &#123; id: n + i &#125; &#125; return &#123; newHouse: randomArr(newHouse), oldHouse: randomArr(oldHouse) &#125;&#125;function randomArr(arr) &#123; //数组洗牌 for (var i = arr.length - 1; i &gt;= 0; i--) &#123; var randomIndex = Math.floor(Math.random() * (i + 1)); var itemAtIndex = arr[randomIndex]; arr[randomIndex] = arr[i]; arr[i] = itemAtIndex; &#125; return arr&#125;const &#123;newHouse,oldHouse&#125; = generateHouses(n) //n为需要构造的数据量const newSetHouse = new Set(newHouse) //构造set数据const newMapHouse = new Map() //构造map数据 for(let index in newHouse)&#123; newMapHouse.set(newHouse[index].id,newHouse[index]) &#125; For循环for循环方法进行两次循环,因为每判断一次新数据就需要遍历一遍老数据,所以时间复杂度为O(N^2),对于1000的数据,最坏的情况要判断1000000次123456789101112131415161718192021222324252627function filterHouse_for(newHouse, oldHouse) &#123; if (newHouse.length === 0) &#123; return &#123; remainHouse: oldHouse, newHouse: newHouse &#125; &#125; let remainHouse = [] let newOutPutouse = [] for (let nIndex in newHouse) &#123; let isNew = true for (let oIndex in oldHouse) &#123; if (newHouse[nIndex].id === oldHouse[oIndex].id) &#123; remainHouse.push(newHouse[nIndex]) isNew = false break &#125; &#125; if (isNew) &#123; newOutPutouse.push(newHouse[nIndex]) &#125; &#125; return &#123; remainHouse, newOutPutouse &#125;&#125; Set方法set是ES6新增的一种数据类型,它的成员是唯一的,所以用来进行去重是非常合适的,总体时间复杂度相较于for循环,它变成了O(NlogN),所以与for循环的时间长短比较取决于系数N,当系数较小时,差别不是很大,但当系数变大时,for循环消耗的时间是成指数级别增加的123456789101112131415function filterHouse_set(newHouse, oldHouse,newSetHouse) &#123; let remainHouse = [] let newOutPutouse = [] for (let index in oldHouse) &#123; if (newSetHouse.has(oldHouse[index])) &#123; remainHouse.push(oldHouse[index]) &#125; else &#123; newOutPutouse.push(oldHouse[index]) &#125; &#125; return &#123; remainHouse, newOutPutouse &#125;&#125; Map方法哈希的时间复杂度为O(1)，因此总的时间复杂度为O(N)，代价是哈希的存储空间通常为数据大小的两倍,并且需要手动先构造map数据1234567891011function filterHouse_map(newHouse,oldHouse,newMapHouse)&#123; let remainHouse = [] let newOutPutouse = [] oldHouse.map(ele=&gt;&#123; newMapHouse.has(ele.id)?remainHouse.push(ele):newOutPutouse.push(ele) &#125;) return &#123; remainHouse, newOutPutouse &#125;&#125; 时间比较写一个函数来比较三种方法需要的时间12345678910111213141516171819202122232425262728function test(n)&#123; const &#123; newHouse, oldHouse &#125; = generateHouses(n) /* for */ console.log('for Start') var time = new Date().getTime() filterHouse_for(newHouse, oldHouse) console.log('for End', new Date().getTime() - time) /* set */ const newSetHouse = new Set(newHouse) //构造set数据 console.log('set Start') var time = new Date().getTime() filterHouse_set(newHouse, oldHouse,newSetHouse) console.log('set End', new Date().getTime() - time) /* map */ const newMapHouse = new Map() //构造map数据 for(let index in newHouse)&#123; newMapHouse.set(newHouse[index].id,newHouse[index]) &#125; console.log('map Start') var time = new Date().getTime() filterHouse_map(newHouse, oldHouse,newMapHouse) console.log('map End', new Date().getTime() - time)&#125; 运行结果(chrome下运行(版本 70))当 n 为10时:1234567test(100)VM253:97 for StartVM253:100 for End 3VM253:104 set StartVM253:107 set End 0VM253:114 map StartVM253:117 map End 0 当 n 为1000时:123456for StartVM253:100 for End 60VM253:104 set StartVM253:107 set End 1VM253:114 map StartVM253:117 map End 0 当 n 为10000时:123456for StartVM253:100 for End 4532VM253:104 set StartVM253:107 set End 5VM253:114 map StartVM253:117 map End 2 当 n 为100000时:因为for循环等了几分钟都没有算出结果,就不比较for循环了1234set StartVM231:102 set End 37VM231:109 map StartVM231:112 map End 30 当 n 为10000000时:123456test(1000000)VM231:99 set StartVM231:102 set End 466VM231:109 map StartVM231:112 map End 592 结论可以看出,不论哪种情况,for循环用时都是最长的,所以不要使用for循环😋,数据量是十万级别以下时,使用map速度比set快一些,十万级别以上时使用set]]></content>
  </entry>
  <entry>
    <title><![CDATA[Fisher–Yates shuffle 洗牌算法]]></title>
    <url>%2Fblog%2F2018%2F11%2F12%2FFisher%E2%80%93Yates%20shuffle%20%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。 Fisher and Yates 的原始版 Fisher–Yates shuffle 的原始版本，最初描述在 1938 年的 Ronald Fisher 和 Frank Yates 写的书中，书名为《Statistical tables for biological, agricultural and medical research》。他们使用纸和笔去描述了这个算法，并使用了一个随机数表来提供随机数。它给出了 1 到 N 的数字的的随机排列，具体步骤如下： 写下从 1 到 N 的数字取一个从 1 到剩下的数字（包括这个数字）的随机数 k从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位重复第 2 步，直到所有的数字都被取出第 3 步写出的这个序列，现在就是原始数字的随机排列已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。 JavaScript 代码实现 12345678910111213141516/** * Fisher–Yates shuffle */Array.prototype.shuffle = function() &#123; var input = this; for (var i = input.length-1; i &gt;=0; i--) &#123; var randomIndex = Math.floor(Math.random()*(i+1)); var itemAtIndex = input[randomIndex]; input[randomIndex] = input[i]; input[i] = itemAtIndex; &#125; return input;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[在npm/yarn中配置.npmrc/.yarnrc文件,设置镜像和代理]]></title>
    <url>%2Fblog%2F2018%2F11%2F12%2F%E5%9C%A8npm-yarn%E4%B8%AD%E9%85%8D%E7%BD%AE-npmrc-yarnrc%E6%96%87%E4%BB%B6-%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[12345//指定淘宝源registry=https://registry.npm.taobao.org//指定代理proxy=http://localhost:1080https-proxy=https://localhost:1080]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用async库结合puppeteer并发爬取网易云音乐歌单(简易demo)]]></title>
    <url>%2Fblog%2F2018%2F11%2F09%2F%E4%BD%BF%E7%94%A8async%E5%BA%93%E5%B9%B6%E5%8F%91%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%AD%8C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[async是node的一个强大的异步第三方库,它包含许多功能方法,今天主要用其中的mapLimit方法来实现并行执行爬虫.mapLimit(coll,limit, iteratee, callbackopt)接收四个参数:coll:是一个迭代器,代表要迭代的集合limit:数字代表同时执行并行的限制iteratee:迭代器方法,对于coll中的每一个item，迭代执行该异步函数。用(item, callback)调用，callback可选callbackopt:所有iteratee 函数完成后或发生错误时触发的回调函数。用(err, results)调用。1234567891011121314151617181920212223242526272829303132333435const puppeteer = require(&apos;puppeteer&apos;)const cheerio = require(&apos;cheerio&apos;)const mapLimit = require(&apos;async/mapLimit&apos;)const URL = &apos;https://music.163.com&apos;//标签集合const type =[&apos;华语&apos;,&apos;欧美&apos;,&apos;日语&apos;,&apos;韩语&apos;,&apos;粤语&apos;,&apos;小语种&apos;]async function start(type,callback)&#123; const browser = await puppeteer.launch(&#123; headless:true &#125;) const page = await browser.newPage() await page.goto(`$&#123;URL&#125;/discover/playlist/?cat=$&#123;type&#125;`) const $ = cheerio.load(await page.mainFrame().childFrames()[0].content()) const list = $(&apos;#m-pl-container&apos;).find(&apos;li&apos;) let album = [] Array.from(list).forEach(ele=&gt;&#123; let obj =&#123; name:$(ele).find(&apos;.dec a&apos;).attr(&apos;title&apos;), href:$(ele).find(&apos;.dec a&apos;).attr(&apos;href&apos;) &#125; album.push(obj) &#125;) callback(null,album) await browser.close()&#125;mapLimit(type,5,(type,callback)=&gt;&#123;//设置并发数为 5 start(type,callback)&#125;,(err,result)=&gt;&#123; for(let index in result)&#123; console.log(result[index]) &#125;&#125;) result:]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Puppeteer爬虫]]></title>
    <url>%2Fblog%2F2018%2F11%2F08%2F%E4%BD%BF%E7%94%A8Puppeteer%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Puppeteer是 GoogleChrome团队官方的无界面（Headless）Chrome工具，它是一个Node库，提供了一个高级的API来控制DevTool协议上的无头版 Chrome 。也可以配置为使用完整（非无头）的 Chrome。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const puppeteer = require('puppeteer')const cheerio = require('cheerio')const fs = require('fs')const assert = require('assert')async function start() &#123; const browser = await puppeteer.launch() const page = await browser.newPage() //过滤请求资源// await page.setRequestInterception(true)// page.on('request', interceptedRequest =&gt; &#123;// if (interceptedRequest.url().endsWith('.png') ||// interceptedRequest.url().endsWith('.jpg') ||// interceptedRequest.url().endsWith('.gif'))// interceptedRequest.abort()// else// interceptedRequest.continue()// &#125;) await page.goto('http://jandan.net/ooxx') const $ = cheerio.load(await page.content()) const $img = $('img') for (let index in $img) &#123; try &#123; const content = await getResourceContent(page, ($img[index].attribs.src)) const contentBuffer = Buffer.from(content, 'base64') const fileName = $img[index].attribs.src.match( /^http(s)?:\/\/(.+)\/(.+)\/(.+\..+)/)[4] fs.writeFileSync(fileName, contentBuffer, 'base64') &#125; catch (e) &#123;&#125; &#125; await browser.close()&#125;//获得资源树async function getResourceTree(page) &#123; var resource = await page._client.send('Page.getResourceTree') return resource.frameTree&#125;//根据url frameId查找资源实例async function getResourceContent(page, url) &#123; const &#123;content, base64Encoded&#125; = await page._client.send( 'Page.getResourceContent', &#123;frameId: String(page.mainFrame()._id), url&#125;, ) assert.strictEqual(base64Encoded, true) return content&#125;start()]]></content>
  </entry>
</search>
