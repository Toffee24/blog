---
title: 前端反爬虫策略
date: 2022-04-02 16:10:14
tags:
---

## 代码压缩/混淆/加密
> 提高理解代码逻辑的难度

webpack内置压缩工具(minimizer)，但也允许使用额外的 TerserPlugin 实例来覆盖

代码压缩、混淆
```javascript
// webpack.config.js
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        minify: TerserPlugin.uglifyJsMinify,
        terserOptions: {
          // 具体配置参考https://github.com/terser/terser#minify-options
        }
    ]
  }
}
```
<!-- more -->

针对代码加密，目前比较终极的方案是```WebAssembly```技术，直接将 JavaScript 代码用 C/C++ 实现，JavaScript 调用其编译后形成的文件来执行相应的功能
```javascript
WebAssembly.compile(new Uint8Array(`
  00 61 73 6d  01 00 00 00  01 0c 02 60  02 7f 7f 01
  7f 60 01 7f  01 7f 03 03  02 00 01 07  10 02 03 61
  64 64 00 00  06 73 71 75  61 72 65 00  01 0a 13 02
  08 00 20 00  20 01 6a 0f  0b 08 00 20  00 20 00 6c
  0f 0b`.trim().split(/[\s\r\n]+/g).map(str => parseInt(str, 16))
)).then(module => {
  const instance = new WebAssembly.Instance(module)
  const { add, square } = instance.exports
  console.log('2 + 4 =', add(2, 4))
  console.log('3^2 =', square(3))
  console.log('(2 + 5)^2 =', square(add(2 + 5)))
})
```


## 开发者工具监测
> 当使用者使用开发者工具查看时，监测并采取相应的阻止操作

基本原理，当浏览者打开浏览器开发者工具时，利用一些浏览器在控制台输出 Object 时，会获取 Object 的 id 的原理，使用`Object.defineProperty`重写对象get方法，以达到阻止目的
```
const element = new Image()
Object.defineProperty(element, 'id', {
get: function() {
  // 阻止
})
console.log(element)
```
这里推荐使用[devtools-detect](https://github.com/sindresorhus/devtools-detect)库，集成了大部分内核浏览器的监测
```javascript
import devtools from './node_modules/devtools-detect/index.js'

window.addEventListener('devtoolschange', event => {
	// 采取阻止操作，如隐藏页面关键元素，重定向页面至空白页等
});
```

## 调试保护
> 无限触发debugger断点，防止第三方调试代码逻辑

代码示例
```javascript
setInterval(function() {
    check()
}, 1000);
const check = function() {
    function doCheck(a) {
        if (("" + a / a)["length"] !== 1 || a % 20 === 0) {
            (function() {}
            ["constructor"]("debugger")())
        } else {
            (function() {}
            ["constructor"]("debugger")())
        }
        doCheck(++a)
    }
    try {
        doCheck(0)
    } catch (err) {}
};
check();
```

### 参数签名（signature）
> 给请求添加一个校验参数，服务器接收到参数后进行校验，若成功则返回数据

- 客户端使用约定好的密钥对请求参数进行加密，得到签名 signature。并将签名加入到请求参数中，发送给服务端
- 服务端接收到客户端请求，使用约定好的密钥对请求参数（不包括 signature）进行再次签名，得到值 autograph
- 服务器对比 signature 和 autograph，相等则认为是一次合法请求，否则则认为参数被篡改，判定为一次非法请求

### 避免重放攻击(timestamp + nonce)
> 当一个合法请求被中间人拦截后，中间人原封不动得重复发送该请求一次或多次，这种重复利用合法请求进行得攻击被称为重放

步骤
1. 客户端将当前 timestamp1、随机字符串和其他请求参数，按照密钥，生成签名 signature
2. 服务端收到请求，利用服务端密钥，将除 timestamp1、随机字符串之外的请求参数，加密生成签名 autograph
3. 服务端对比 signature 和 autograph，不相等则认为非法请求
4. 拿到服务端时间戳， timestamp2 - timestamp1 < 60，则判定为一次合法请求，然后保存 nonce
5. 服务端只保存60秒内的 nonce，定时将集合内过期的 nonce 删除

### 字体文件反爬
> 前端加载特殊的字体文件使乱码文字显示正常

针对于数字敏感的网站，这个方法比较合适，如携程网酒店价格，猫眼网票房数据等。缺点是复制的内容也是乱码，且需要对字体文件定时更换。
